<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SPEC-TAPE | Kiroween Mixtape Analyzer</title>
    
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Tone.js for Web Audio API -->
    <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>
    
    <!-- Custom Tailwind Configuration -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'spec-dark': '#111827',
                        'neon-purple': '#BF40BF',
                        'radioactive-green': '#40BF40',
                        'shock-orange': '#FF8C00',
                        'terminal-green': '#00FF00'
                    },
                    fontFamily: {
                        'mono': ['Courier New', 'monospace'],
                        'pixel': ['Courier New', 'Monaco', 'Lucida Console', 'monospace']
                    }
                }
            }
        }
    </script>
    
    <style>
        /* Custom 90s Aesthetic Styles */
        body {
            background: linear-gradient(135deg, #111827 0%, #1f2937 100%);
            font-family: 'Courier New', monospace;
        }
        
        /* 3D Button Effects */
        .btn-3d {
            box-shadow: 
                0 4px 0 #374151,
                0 8px 16px rgba(0, 0, 0, 0.3);
            transform: translateY(0);
            transition: all 0.1s ease;
        }
        
        .btn-3d:hover {
            transform: translateY(-2px);
            box-shadow: 
                0 6px 0 #374151,
                0 12px 20px rgba(0, 0, 0, 0.4);
        }
        
        .btn-3d:active {
            transform: translateY(4px);
            box-shadow: 
                0 0 0 #374151,
                0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        /* Neon Glow Effects */
        .neon-glow {
            text-shadow: 
                0 0 5px currentColor,
                0 0 10px currentColor,
                0 0 15px currentColor;
        }
        
        /* CRT Monitor Effect */
        .crt-effect {
            position: relative;
            overflow: hidden;
        }
        
        .crt-effect::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(
                transparent 50%,
                rgba(0, 255, 0, 0.03) 50%
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 1;
        }
        
        /* Tape Spool Animation */
        @keyframes spin-spool {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        @keyframes spin-spool-slow {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .tape-spool {
            animation: spin-spool 3s linear infinite;
            animation-play-state: paused;
            transition: all 0.3s ease;
        }
        
        .tape-spool.playing {
            animation-play-state: running;
        }
        
        .tape-spool.fast-forward {
            animation: spin-spool 0.5s linear infinite;
            animation-play-state: running;
        }
        
        .tape-spool.rewind {
            animation: spin-spool 0.5s linear infinite reverse;
            animation-play-state: running;
        }
        
        /* Tape spool inner details */
        .spool-inner {
            position: relative;
            overflow: hidden;
        }
        
        .spool-inner::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 80%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #4b5563, transparent);
            transform: translate(-50%, -50%);
        }
        
        .spool-inner::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2px;
            height: 80%;
            background: linear-gradient(0deg, transparent, #4b5563, transparent);
            transform: translate(-50%, -50%);
        }
        
        /* Cassette tape visual enhancement */
        .cassette-tape {
            background: linear-gradient(90deg, 
                #1f2937 0%, 
                #374151 20%, 
                #4b5563 50%, 
                #374151 80%, 
                #1f2937 100%);
            position: relative;
        }
        
        .cassette-tape::before {
            content: '';
            position: absolute;
            top: 2px;
            left: 10%;
            right: 10%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #6b7280, transparent);
        }
        
        .cassette-tape::after {
            content: '';
            position: absolute;
            bottom: 2px;
            left: 10%;
            right: 10%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #6b7280, transparent);
        }
        
        /* Static Overlay for Easter Egg */
        .static-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle, transparent 20%, rgba(0, 255, 0, 0.1) 20.5%, rgba(0, 255, 0, 0.1) 80%, transparent 80.5%),
                linear-gradient(90deg, transparent 50%, rgba(0, 255, 0, 0.05) 50%);
            background-size: 20px 20px, 3px 3px;
            opacity: 0;
            pointer-events: none;
            z-index: 9999;
            transition: opacity 0.3s ease;
        }
        
        .static-overlay.active {
            opacity: 1;
        }
        
        /* Terminal-style text */
        .terminal-text {
            font-family: 'Courier New', monospace;
            color: #00FF00;
            background: #000;
            padding: 1rem;
            border-radius: 4px;
            white-space: pre-wrap;
            word-break: break-word;
        }
        
        /* Boombox specific styling */
        .boombox-container {
            background: linear-gradient(145deg, #374151, #1f2937);
            border: 4px solid #4b5563;
            box-shadow: 
                inset 0 2px 4px rgba(255, 255, 255, 0.1),
                inset 0 -2px 4px rgba(0, 0, 0, 0.3),
                0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        .cassette-display {
            background: linear-gradient(145deg, #111827, #1f2937);
            box-shadow: 
                inset 0 2px 4px rgba(0, 0, 0, 0.5),
                inset 0 -1px 2px rgba(255, 255, 255, 0.1);
        }
        
        /* Control button active states */
        .control-button.active {
            background: #BF40BF !important;
            color: white !important;
            box-shadow: 
                0 2px 0 #9333ea,
                0 4px 8px rgba(0, 0, 0, 0.3);
            transform: translateY(2px);
        }
        
        /* Specific button active states */
        #playBtn.active {
            background: #22c55e !important;
            box-shadow: 
                0 2px 0 #16a34a,
                0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        #pauseBtn.active {
            background: #f59e0b !important;
            box-shadow: 
                0 2px 0 #d97706,
                0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        #stopBtn.active {
            background: #dc2626 !important;
            box-shadow: 
                0 2px 0 #b91c1c,
                0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        #fastForwardBtn.active, #rewindBtn.active {
            background: #FF8C00 !important;
            color: black !important;
            box-shadow: 
                0 2px 0 #ea580c,
                0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        /* Spotify button styling */
        #createSpotifyPlaylistBtn {
            background: linear-gradient(145deg, #1db954, #1ed760) !important;
            transition: all 0.3s ease;
        }
        
        #createSpotifyPlaylistBtn:hover {
            background: linear-gradient(145deg, #1ed760, #1db954) !important;
            transform: translateY(-1px);
            box-shadow: 
                0 6px 0 #169c46,
                0 12px 20px rgba(0, 0, 0, 0.4);
        }
        
        #createSpotifyPlaylistBtn:active {
            transform: translateY(2px);
            box-shadow: 
                0 2px 0 #169c46,
                0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        .side-selector.active {
            background: #BF40BF !important;
            color: white !important;
            transform: translateY(2px);
            box-shadow: 
                0 2px 0 #9333ea,
                0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        /* Hover effects for cassette label */
        #cassette-label:hover {
            background: #4b5563 !important;
        }
        
        /* Track input styling */
        .track-input {
            background: #000;
            border: 2px solid #374151;
            color: #40BF40;
            font-family: 'Courier New', monospace;
            transition: all 0.3s ease;
        }
        
        .track-input:focus {
            border-color: #BF40BF;
            box-shadow: 0 0 10px rgba(191, 64, 191, 0.3);
            outline: none;
        }
        
        .track-input::placeholder {
            color: #6b7280;
        }
        
        /* Track container styling */
        .track-container {
            background: linear-gradient(145deg, #1f2937, #111827);
            border: 1px solid #374151;
            transition: all 0.3s ease;
            overflow: hidden; /* Prevent content overflow */
        }
        
        .track-container:hover {
            border-color: #4b5563;
            background: linear-gradient(145deg, #374151, #1f2937);
        }
        
        /* Track container flex layout */
        .track-container .flex {
            flex-wrap: nowrap;
            align-items: center;
            gap: 0.5rem;
        }
        
        /* Ensure buttons stay within bounds */
        .track-container .flex > div:last-child {
            flex-shrink: 0;
            display: flex;
            gap: 0.25rem;
        }
        
        /* Track number styling */
        .track-number {
            background: linear-gradient(145deg, #374151, #1f2937);
            color: #BF40BF;
            border: 1px solid #4b5563;
            font-weight: bold;
            text-shadow: 0 0 5px currentColor;
        }
        
        /* Remove track button */
        .remove-track {
            background: #dc2626;
            color: white;
            border: none;
            transition: all 0.2s ease;
        }
        
        .remove-track:hover {
            background: #b91c1c;
            transform: scale(1.1);
        }
        
        /* Volume slider styling */
        .volume-slider {
            -webkit-appearance: none;
            appearance: none;
            background: #374151;
            outline: none;
            border-radius: 4px;
        }
        
        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #BF40BF;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(191, 64, 191, 0.5);
        }
        
        .volume-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #BF40BF;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(191, 64, 191, 0.5);
        }
        
        .volume-slider:hover::-webkit-slider-thumb {
            background: #d946ef;
            box-shadow: 0 0 15px rgba(191, 64, 191, 0.8);
        }
        
        /* Track selector styling */
        .track-select-btn {
            background: linear-gradient(145deg, #1f2937, #111827);
            border: 1px solid #374151;
            color: #9ca3af;
            transition: all 0.3s ease;
            font-family: 'Courier New', monospace;
        }
        
        .track-select-btn:hover {
            border-color: #BF40BF;
            color: #BF40BF;
            background: linear-gradient(145deg, #374151, #1f2937);
        }
        
        .track-select-btn.current-track {
            background: linear-gradient(145deg, #BF40BF, #9333ea);
            color: white;
            border-color: #d946ef;
            box-shadow: 0 0 10px rgba(191, 64, 191, 0.3);
        }
        
        .track-select-btn.playing {
            animation: pulse-glow 2s ease-in-out infinite alternate;
        }
        
        @keyframes pulse-glow {
            from {
                box-shadow: 0 0 10px rgba(191, 64, 191, 0.3);
            }
            to {
                box-shadow: 0 0 20px rgba(191, 64, 191, 0.8);
            }
        }
        
        /* EVP Analysis styling */
        #evpTranscript {
            background: linear-gradient(145deg, #000, #111827);
            border: 2px solid #374151;
            color: #40BF40;
            font-family: 'Courier New', monospace;
            line-height: 1.4;
        }
        
        #evpTranscript:focus {
            border-color: #FF8C00;
            box-shadow: 0 0 15px rgba(255, 140, 0, 0.3);
        }
        
        #evpTranscript::placeholder {
            color: #6b7280;
            font-style: italic;
        }
        
        .evp-sample {
            transition: all 0.3s ease;
        }
        
        .evp-sample:hover {
            background: #4b5563 !important;
            color: #FF8C00 !important;
            transform: translateY(-1px);
        }
        
        /* Analysis progress animation */
        @keyframes analysis-pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }
        
        .analyzing {
            animation: analysis-pulse 1.5s ease-in-out infinite;
        }
        
        /* Loading dots animation */
        @keyframes loading-dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }
        
        .loading-dots::after {
            content: '.';
            animation: loading-dots 1.5s infinite;
        }
        
        /* Screen shake animation for Konami code */
        @keyframes screen-shake {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            10% { transform: translate(-2px, -1px) rotate(-0.5deg); }
            20% { transform: translate(-1px, 0px) rotate(0.5deg); }
            30% { transform: translate(2px, 1px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(0.5deg); }
            50% { transform: translate(-1px, 1px) rotate(-0.5deg); }
            60% { transform: translate(-2px, 0px) rotate(0deg); }
            70% { transform: translate(2px, 1px) rotate(-0.5deg); }
            80% { transform: translate(-1px, -1px) rotate(0.5deg); }
            90% { transform: translate(1px, 0px) rotate(0deg); }
        }
        
        /* ===== HALLOWEEN THEMED ENHANCEMENTS ===== */
        
        /* Floating ghosts background */
        @keyframes float-ghost {
            0%, 100% { 
                transform: translateY(0) translateX(0);
                opacity: 0.1;
            }
            50% { 
                transform: translateY(-30px) translateX(10px);
                opacity: 0.3;
            }
        }
        
        .ghost-bg {
            position: fixed;
            font-size: 3rem;
            opacity: 0.1;
            pointer-events: none;
            z-index: 0;
            animation: float-ghost 8s ease-in-out infinite;
        }
        
        /* Spooky glow effect */
        @keyframes spooky-glow {
            0%, 100% { 
                box-shadow: 0 0 10px rgba(255, 140, 0, 0.3),
                           0 0 20px rgba(191, 64, 191, 0.2);
            }
            50% { 
                box-shadow: 0 0 20px rgba(255, 140, 0, 0.6),
                           0 0 40px rgba(191, 64, 191, 0.4),
                           0 0 60px rgba(64, 191, 64, 0.2);
            }
        }
        
        .spooky-glow {
            animation: spooky-glow 3s ease-in-out infinite;
        }
        
        /* Flickering text effect */
        @keyframes flicker {
            0%, 100% { opacity: 1; }
            41%, 43% { opacity: 0.8; }
            45%, 47% { opacity: 0.9; }
            49% { opacity: 0.7; }
            51% { opacity: 1; }
        }
        
        .flicker-text {
            animation: flicker 4s linear infinite;
        }
        
        /* Creepy shadow pulse */
        @keyframes shadow-pulse {
            0%, 100% { 
                filter: drop-shadow(0 0 5px rgba(255, 140, 0, 0.5));
            }
            50% { 
                filter: drop-shadow(0 0 20px rgba(255, 140, 0, 0.9))
                       drop-shadow(0 0 30px rgba(191, 64, 191, 0.6));
            }
        }
        
        .shadow-pulse {
            animation: shadow-pulse 2s ease-in-out infinite;
        }
        
        /* Dripping blood effect */
        @keyframes drip {
            0% { 
                transform: translateY(0);
                opacity: 1;
            }
            100% { 
                transform: translateY(20px);
                opacity: 0;
            }
        }
        
        .blood-drip::after {
            content: '‚ñº';
            position: absolute;
            color: #dc2626;
            font-size: 0.5rem;
            animation: drip 2s ease-in infinite;
        }
        
        /* Pumpkin emoji decorations */
        .pumpkin-decoration {
            display: inline-block;
            animation: float-ghost 6s ease-in-out infinite;
            filter: drop-shadow(0 0 8px rgba(255, 140, 0, 0.8));
        }
        
        /* Bat flying animation */
        @keyframes fly-bat {
            0% { 
                transform: translateX(-100vw) translateY(0) scaleX(1);
            }
            45% {
                transform: translateX(50vw) translateY(-20px) scaleX(1);
            }
            50% {
                transform: translateX(50vw) translateY(-20px) scaleX(-1);
            }
            100% { 
                transform: translateX(120vw) translateY(0) scaleX(-1);
            }
        }
        
        .flying-bat {
            position: fixed;
            font-size: 2rem;
            opacity: 0.4;
            pointer-events: none;
            z-index: 1;
            animation: fly-bat 15s linear infinite;
        }
        
        /* Cobweb corners */
        .cobweb-corner {
            position: absolute;
            width: 100px;
            height: 100px;
            opacity: 0.3;
            pointer-events: none;
        }
        
        .cobweb-corner::before {
            content: 'üï∏Ô∏è';
            position: absolute;
            font-size: 4rem;
            filter: grayscale(100%) brightness(0.5);
        }
        
        .cobweb-top-left {
            top: 0;
            left: 0;
        }
        
        .cobweb-top-right {
            top: 0;
            right: 0;
            transform: scaleX(-1);
        }
        
        /* Glowing eyes effect */
        @keyframes blink-eyes {
            0%, 90%, 100% { opacity: 1; }
            93%, 96% { opacity: 0; }
        }
        
        .glowing-eyes {
            animation: blink-eyes 8s ease-in-out infinite;
            text-shadow: 0 0 10px currentColor;
        }
        
        /* Haunted border effect */
        @keyframes haunted-border {
            0%, 100% { 
                border-color: #4b5563;
                box-shadow: inset 0 0 10px rgba(255, 140, 0, 0.2);
            }
            50% { 
                border-color: #FF8C00;
                box-shadow: inset 0 0 20px rgba(255, 140, 0, 0.5),
                           0 0 30px rgba(191, 64, 191, 0.3);
            }
        }
        
        .haunted-border {
            animation: haunted-border 4s ease-in-out infinite;
        }
        
        /* Fog effect */
        @keyframes fog-drift {
            0% { 
                transform: translateX(-10%) translateY(0);
                opacity: 0.1;
            }
            50% { 
                opacity: 0.3;
            }
            100% { 
                transform: translateX(10%) translateY(-5px);
                opacity: 0.1;
            }
        }
        
        .fog-layer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 200px;
            background: linear-gradient(to top, rgba(191, 64, 191, 0.1), transparent);
            pointer-events: none;
            z-index: 1;
            animation: fog-drift 10s ease-in-out infinite;
        }
        
        /* Creepy cursor trail */
        body {
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><text y="20" font-size="20">üëª</text></svg>'), auto;
        }
        
        /* Spooky hover effects for buttons */
        .btn-3d:hover {
            box-shadow: 
                0 6px 0 #374151,
                0 12px 20px rgba(255, 140, 0, 0.4),
                0 0 30px rgba(191, 64, 191, 0.3);
        }
        
        /* Halloween themed scrollbar */
        ::-webkit-scrollbar {
            width: 12px;
        }
        
        ::-webkit-scrollbar-track {
            background: #111827;
            border: 1px solid #FF8C00;
        }
        
        ::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #FF8C00, #BF40BF);
            border-radius: 6px;
            border: 2px solid #111827;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, #BF40BF, #FF8C00);
            box-shadow: 0 0 10px rgba(255, 140, 0, 0.8);
        }
        
        /* Spooky text selection */
        ::selection {
            background: rgba(255, 140, 0, 0.5);
            color: #000;
            text-shadow: 0 0 5px rgba(191, 64, 191, 0.8);
        }
        
        /* Enhanced body background with moving shadows */
        body {
            background: 
                radial-gradient(circle at 20% 80%, rgba(191, 64, 191, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 140, 0, 0.1) 0%, transparent 50%),
                linear-gradient(135deg, #111827 0%, #1f2937 100%);
            background-size: 200% 200%;
            animation: bg-shift 20s ease infinite;
        }
        
        @keyframes bg-shift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
    </style>
</head>
<body class="bg-spec-dark text-white min-h-screen">
    <!-- Static Overlay for Konami Code Easter Egg -->
    <div id="staticOverlay" class="static-overlay"></div>
    
    <!-- Halloween Decorative Elements -->
    <div class="fog-layer"></div>
    
    <!-- Floating Ghosts -->
    <div class="ghost-bg" style="top: 10%; left: 5%; animation-delay: 0s;">üëª</div>
    <div class="ghost-bg" style="top: 30%; right: 10%; animation-delay: 2s;">üëª</div>
    <div class="ghost-bg" style="bottom: 20%; left: 15%; animation-delay: 4s;">üëª</div>
    <div class="ghost-bg" style="top: 60%; right: 20%; animation-delay: 6s;">üëª</div>
    
    <!-- Flying Bats -->
    <div class="flying-bat" style="top: 15%; animation-delay: 0s;">ü¶á</div>
    <div class="flying-bat" style="top: 45%; animation-delay: 7s;">ü¶á</div>
    <div class="flying-bat" style="top: 75%; animation-delay: 14s;">ü¶á</div>
    
    <!-- Cobwebs in corners -->
    <div class="cobweb-corner cobweb-top-left"></div>
    <div class="cobweb-corner cobweb-top-right"></div>
    
    <!-- Main Application Container -->
    <div class="container mx-auto px-4 py-8 max-w-4xl">
        <!-- Header -->
        <header class="text-center mb-8 relative">
            <div class="flex justify-center items-center gap-4 mb-2">
                <span class="pumpkin-decoration text-4xl">üéÉ</span>
                <h1 class="text-6xl font-bold text-neon-purple neon-glow font-pixel flicker-text">
                    SPEC-TAPE
                </h1>
                <span class="pumpkin-decoration text-4xl" style="animation-delay: 3s;">üéÉ</span>
            </div>
            <p class="text-radioactive-green text-lg font-mono shadow-pulse">
                KIROWEEN MIXTAPE ANALYZER v1.0
            </p>
            <div class="text-shock-orange text-sm font-mono mt-2 flex items-center justify-center gap-2">
                <span class="glowing-eyes">üëÅÔ∏è</span>
                [PARANORMAL AUDIO INVESTIGATION SYSTEM]
                <span class="glowing-eyes" style="animation-delay: 4s;">üëÅÔ∏è</span>
            </div>
            <div class="mt-3 text-xs font-mono text-gray-400 flex items-center justify-center gap-2">
                <span>üï∑Ô∏è</span>
                <span class="flicker-text">‚ö†Ô∏è WARNING: SUPERNATURAL ACTIVITY DETECTED ‚ö†Ô∏è</span>
                <span>üï∑Ô∏è</span>
            </div>
        </header>
        
        <!-- Main Boombox Container -->
        <main class="boombox-container bg-gray-800 rounded-lg p-8 border-4 border-gray-600 crt-effect shadow-2xl spooky-glow haunted-border"></main>
            
            <!-- Cassette Display Section -->
            <div class="cassette-display bg-gray-900 rounded-lg p-6 mb-6 border-2 border-gray-500">
                <div class="flex justify-between items-center mb-4">
                    <!-- Left Tape Spool -->
                    <div id="leftSpool" class="tape-spool w-16 h-16 bg-gray-700 rounded-full border-4 border-gray-500 flex items-center justify-center shadow-lg">
                        <div class="w-10 h-10 bg-gray-600 rounded-full border-2 border-gray-400 shadow-inner">
                            <div class="spool-inner w-full h-full bg-gradient-to-br from-gray-500 to-gray-700 rounded-full flex items-center justify-center">
                                <div class="w-3 h-3 bg-gray-800 rounded-full border border-gray-600">
                                    <div class="w-full h-full bg-gradient-to-br from-gray-700 to-gray-900 rounded-full"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Cassette Tape Center -->
                    <div class="flex-1 mx-4 cassette-tape bg-gray-800 rounded p-4 border border-gray-600 shadow-inner">
                        <div class="text-center">
                            <div class="text-radioactive-green font-mono text-sm mb-2 neon-glow">
                                SPEC-TAPE LOADED
                            </div>
                            <div class="bg-black rounded p-2 mb-2 border border-gray-700 shadow-inner">
                                <div id="tapeTitle" class="text-shock-orange font-mono text-xs">
                                    [UNTITLED MIXTAPE]
                                </div>
                            </div>
                            <div class="flex justify-between text-xs font-mono text-gray-400">
                                <span id="currentSide" class="text-neon-purple">SIDE A</span>
                                <span id="trackCounter">00/00</span>
                            </div>
                            
                            <!-- Tape Progress Indicator -->
                            <div class="mt-2 bg-black rounded p-1 border border-gray-700">
                                <div class="flex justify-between items-center">
                                    <div class="w-2 h-1 bg-radioactive-green rounded"></div>
                                    <div id="tapeProgress" class="flex-1 mx-2 h-1 bg-gray-700 rounded overflow-hidden">
                                        <div class="h-full bg-gradient-to-r from-radioactive-green to-neon-purple w-0 transition-all duration-1000"></div>
                                    </div>
                                    <div class="w-2 h-1 bg-radioactive-green rounded"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Right Tape Spool -->
                    <div id="rightSpool" class="tape-spool w-16 h-16 bg-gray-700 rounded-full border-4 border-gray-500 flex items-center justify-center shadow-lg">
                        <div class="w-10 h-10 bg-gray-600 rounded-full border-2 border-gray-400 shadow-inner">
                            <div class="spool-inner w-full h-full bg-gradient-to-br from-gray-500 to-gray-700 rounded-full flex items-center justify-center">
                                <div class="w-3 h-3 bg-gray-800 rounded-full border border-gray-600">
                                    <div class="w-full h-full bg-gradient-to-br from-gray-700 to-gray-900 rounded-full"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Cassette Label Area (Hidden Click Target) -->
                <div id="cassette-label" class="bg-gray-700 rounded p-2 border border-gray-500 cursor-pointer hover:bg-gray-650 transition-colors">
                    <div class="text-center text-xs font-mono text-gray-300">
                        KIROWEEN PARANORMAL INVESTIGATION
                    </div>
                    <div class="text-center text-xs font-mono text-gray-400 mt-1">
                        SPECTRAL ANALYSIS DIVISION
                    </div>
                </div>
            </div>
            
            <!-- Control Panel -->
            <div class="bg-gray-700 rounded-lg p-6 border-2 border-gray-500">
                <div class="grid grid-cols-2 gap-6">
                    
                    <!-- Left Control Section -->
                    <div>
                        <h2 class="text-radioactive-green font-mono text-sm mb-4 neon-glow">
                            PLAYBACK CONTROLS
                        </h2>
                        
                        <!-- Transport Controls -->
                        <div class="grid grid-cols-2 gap-2 mb-4">
                            <button id="rewindBtn" class="control-button btn-3d bg-gray-600 text-white px-3 py-2 rounded font-mono text-xs font-bold hover:bg-gray-500">
                                ‚è™ REW
                            </button>
                            <button id="fastForwardBtn" class="control-button btn-3d bg-gray-600 text-white px-3 py-2 rounded font-mono text-xs font-bold hover:bg-gray-500">
                                FF ‚è©
                            </button>
                            <button id="playBtn" class="control-button btn-3d bg-radioactive-green text-black px-4 py-2 rounded font-mono text-sm font-bold hover:bg-green-400 col-span-2">
                                ‚ñ∂ PLAY
                            </button>
                        </div>
                        
                        <div class="flex space-x-2 mb-4">
                            <button id="pauseBtn" class="control-button btn-3d bg-shock-orange text-black px-4 py-2 rounded font-mono text-sm font-bold hover:bg-orange-400 flex-1">
                                ‚è∏ PAUSE
                            </button>
                            <button id="stopBtn" class="control-button btn-3d bg-red-500 text-white px-4 py-2 rounded font-mono text-sm font-bold hover:bg-red-400 flex-1">
                                ‚èπ STOP
                            </button>
                        </div>
                        
                        <!-- Side Selector -->
                        <div class="mb-4">
                            <label class="text-neon-purple font-mono text-xs mb-2 block">TAPE SIDE:</label>
                            <div class="flex space-x-2">
                                <button id="sideABtn" class="side-selector btn-3d bg-neon-purple text-white px-3 py-1 rounded font-mono text-sm font-bold hover:bg-purple-400 active">
                                    SIDE A
                                </button>
                                <button id="sideBBtn" class="side-selector btn-3d bg-gray-600 text-white px-3 py-1 rounded font-mono text-sm font-bold hover:bg-gray-500">
                                    SIDE B
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Right Control Section -->
                    <div>
                        <h2 class="text-shock-orange font-mono text-sm mb-4 neon-glow">
                            SYSTEM STATUS
                        </h2>
                        
                        <!-- Status Indicators -->
                        <div class="space-y-2 text-xs font-mono">
                            <div class="flex justify-between">
                                <span class="text-gray-400">POWER:</span>
                                <span class="text-radioactive-green neon-glow">ONLINE</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-gray-400">SPECTRAL:</span>
                                <span class="text-radioactive-green neon-glow">READY</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-gray-400">ANALYSIS:</span>
                                <span id="analysisStatus" class="text-gray-400">STANDBY</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-gray-400">AUDIO:</span>
                                <span id="audioStatus" class="text-gray-400">INIT</span>
                            </div>
                        </div>
                        
                        <!-- Volume Control -->
                        <div class="mt-4">
                            <label for="volumeSlider" class="text-neon-purple font-mono text-xs mb-2 block">VOLUME:</label>
                            <div class="bg-black rounded p-2">
                                <input 
                                    type="range" 
                                    id="volumeSlider" 
                                    min="0" 
                                    max="100" 
                                    value="70" 
                                    class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer volume-slider"
                                    aria-label="Volume control"
                                    aria-valuemin="0"
                                    aria-valuemax="100"
                                    aria-valuenow="70"
                                    aria-valuetext="70 percent"
                                >
                                <div class="flex justify-between text-xs text-gray-400 font-mono mt-1">
                                    <span>0</span>
                                    <span id="volumeDisplay" aria-live="polite">70%</span>
                                    <span>100</span>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Track Selection -->
                        <div class="mt-4">
                            <label class="text-shock-orange font-mono text-xs mb-2 block">TRACK SELECT:</label>
                            <div class="bg-black rounded p-2 max-h-32 overflow-y-auto">
                                <div id="trackSelector" class="space-y-1">
                                    <!-- Track selection buttons will be populated here -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>
        
        <!-- Mixtape Editor Section -->
        <section class="bg-gray-800 rounded-lg p-6 border-4 border-gray-600 mt-6 crt-effect shadow-2xl spooky-glow haunted-border relative">
            <!-- Spooky decorations -->
            <div class="absolute top-2 left-2 text-xl opacity-40">üéÉ</div>
            <div class="absolute top-2 right-2 text-xl opacity-40">üéÉ</div>
            
            <header class="text-center mb-6">
                <div class="flex justify-center items-center gap-3 mb-2">
                    <span class="text-2xl pumpkin-decoration">üéµ</span>
                    <h2 class="text-3xl font-bold text-neon-purple neon-glow font-pixel shadow-pulse">
                        MIXTAPE EDITOR
                    </h2>
                    <span class="text-2xl pumpkin-decoration" style="animation-delay: 2s;">üéµ</span>
                </div>
                <p class="text-radioactive-green text-sm font-mono flex items-center justify-center gap-2">
                    <span>ü¶á</span>
                    [CUSTOMIZE YOUR SPECTRAL COMPILATION]
                    <span>ü¶á</span>
                </p>
            </header>
            
            <!-- Mixtape Title Input -->
            <div class="mb-6">
                <label for="mixtapeTitle" class="block text-shock-orange font-mono text-sm mb-2 neon-glow">
                    TAPE TITLE:
                </label>
                <input 
                    type="text" 
                    id="mixtapeTitle" 
                    class="w-full bg-black border-2 border-gray-600 rounded p-3 text-radioactive-green font-mono text-lg focus:border-neon-purple focus:outline-none focus:ring-2 focus:ring-neon-purple focus:ring-opacity-50 transition-all"
                    placeholder="Enter your mixtape title..."
                    maxlength="50"
                >
                <div class="text-right text-xs text-gray-400 font-mono mt-1">
                    <span id="titleCharCount">0</span>/50 characters
                </div>
            </div>
            
            <!-- Side A and B Editor -->
            <div class="grid md:grid-cols-2 gap-6">
                
                <!-- Side A -->
                <div class="bg-gray-900 rounded-lg p-4 border-2 border-gray-500">
                    <h3 class="text-radioactive-green font-mono text-lg mb-4 neon-glow text-center">
                        ‚óÑ SIDE A ‚ñ∫
                    </h3>
                    
                    <div id="sideAEditor" class="space-y-2">
                        <!-- Track inputs will be dynamically generated -->
                    </div>
                    
                    <button id="addTrackA" class="w-full mt-3 btn-3d bg-radioactive-green text-black px-4 py-2 rounded font-mono text-sm font-bold hover:bg-green-400">
                        + ADD TRACK TO SIDE A
                    </button>
                    
                    <div class="text-center text-xs text-gray-400 font-mono mt-2 space-y-1">
                        <div><span id="sideACount">0</span>/10 tracks</div>
                        <div>Duration: <span id="sideADuration">0:00</span></div>
                    </div>
                </div>
                
                <!-- Side B -->
                <div class="bg-gray-900 rounded-lg p-4 border-2 border-gray-500">
                    <h3 class="text-neon-purple font-mono text-lg mb-4 neon-glow text-center">
                        ‚óÑ SIDE B ‚ñ∫
                    </h3>
                    
                    <div id="sideBEditor" class="space-y-2">
                        <!-- Track inputs will be dynamically generated -->
                    </div>
                    
                    <button id="addTrackB" class="w-full mt-3 btn-3d bg-neon-purple text-white px-4 py-2 rounded font-mono text-sm font-bold hover:bg-purple-400">
                        + ADD TRACK TO SIDE B
                    </button>
                    
                    <div class="text-center text-xs text-gray-400 font-mono mt-2 space-y-1">
                        <div><span id="sideBCount">0</span>/10 tracks</div>
                        <div>Duration: <span id="sideBDuration">0:00</span></div>
                    </div>
                </div>
            </div>
            
            <!-- Mixtape Actions -->
            <div class="flex justify-center space-x-4 mt-6">
                <button id="clearMixtape" class="btn-3d bg-red-500 text-white px-6 py-2 rounded font-mono text-sm font-bold hover:bg-red-400">
                    CLEAR ALL
                </button>
                <button id="randomizeTracks" class="btn-3d bg-shock-orange text-black px-6 py-2 rounded font-mono text-sm font-bold hover:bg-orange-400">
                    RANDOMIZE
                </button>
            </div>
            
            <!-- Mixtape Sharing Section -->
            <div class="mt-6 bg-gray-900 rounded-lg p-4 border border-gray-600">
                <h4 class="text-shock-orange font-mono text-sm mb-3 text-center neon-glow">
                    SHARE YOUR SPEC-TAPE
                </h4>
                
                <div class="grid grid-cols-2 md:grid-cols-4 gap-2">
                    <button id="shareTracklistBtn" class="btn-3d bg-neon-purple text-white px-3 py-2 rounded font-mono text-xs font-bold hover:bg-purple-400">
                        SHARE TRACKLIST
                    </button>
                    <button id="shareMixtapeDataBtn" class="btn-3d bg-radioactive-green text-black px-3 py-2 rounded font-mono text-xs font-bold hover:bg-green-400">
                        EXPORT DATA
                    </button>
                    <button id="generateShareLinkBtn" class="btn-3d bg-shock-orange text-black px-3 py-2 rounded font-mono text-xs font-bold hover:bg-orange-400">
                        GENERATE LINK
                    </button>
                    <button id="createSpotifyPlaylistBtn" class="btn-3d bg-green-500 text-black px-3 py-2 rounded font-mono text-xs font-bold hover:bg-green-400">
                        CREATE SPOTIFY PLAYLIST
                    </button>
                    <button id="importDataBtn" class="btn-3d bg-gray-600 text-white px-3 py-2 rounded font-mono text-xs font-bold hover:bg-gray-500">
                        IMPORT DATA
                    </button>
                </div>
                
                <!-- Import Modal -->
                <div id="importModal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 hidden">
                    <div class="bg-gray-800 rounded-lg p-6 border-2 border-gray-600 max-w-md w-full mx-4">
                        <h3 class="text-radioactive-green font-mono text-lg mb-4 text-center neon-glow">
                            IMPORT MIXTAPE DATA
                        </h3>
                        <textarea 
                            id="importDataInput" 
                            class="w-full bg-black border-2 border-gray-600 rounded p-3 text-radioactive-green font-mono text-sm focus:border-neon-purple focus:outline-none resize-none"
                            placeholder="Paste exported mixtape data here..."
                            rows="8"
                        ></textarea>
                        <div class="flex justify-center space-x-3 mt-4">
                            <button id="confirmImportBtn" class="btn-3d bg-radioactive-green text-black px-4 py-2 rounded font-mono text-xs font-bold hover:bg-green-400">
                                IMPORT
                            </button>
                            <button id="cancelImportBtn" class="btn-3d bg-red-500 text-white px-4 py-2 rounded font-mono text-xs font-bold hover:bg-red-400">
                                CANCEL
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Share Status -->
                <div id="shareStatus" class="mt-3 text-center hidden">
                    <div class="bg-black rounded p-2 border border-radioactive-green">
                        <div class="text-radioactive-green font-mono text-xs neon-glow">
                            MIXTAPE DATA COPIED TO CLIPBOARD
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Keyboard Shortcuts Help -->
            <div class="mt-6 bg-gray-900 rounded-lg p-4 border border-gray-600">
                <h4 class="text-radioactive-green font-mono text-sm mb-3 text-center neon-glow">
                    KEYBOARD SHORTCUTS
                </h4>
                <div class="grid grid-cols-2 gap-2 text-xs font-mono text-gray-400">
                    <div class="flex justify-between">
                        <span>SPACE:</span>
                        <span class="text-neon-purple">Play/Pause</span>
                    </div>
                    <div class="flex justify-between">
                        <span>S:</span>
                        <span class="text-red-400">Stop</span>
                    </div>
                    <div class="flex justify-between">
                        <span>‚Üê ‚Üí:</span>
                        <span class="text-shock-orange">Prev/Next Track</span>
                    </div>
                    <div class="flex justify-between">
                        <span>A / B:</span>
                        <span class="text-radioactive-green">Switch Sides</span>
                    </div>
                </div>
            </div>
        </section>
        
        <!-- EVP Analysis Section -->
        <section class="bg-gray-800 rounded-lg p-6 border-4 border-gray-600 mt-6 crt-effect shadow-2xl spooky-glow haunted-border relative">
            <!-- Spooky corner decorations -->
            <div class="absolute top-2 left-2 text-2xl opacity-50">üï∏Ô∏è</div>
            <div class="absolute top-2 right-2 text-2xl opacity-50 transform scale-x-[-1]">üï∏Ô∏è</div>
            
            <header class="text-center mb-6">
                <div class="flex justify-center items-center gap-3 mb-2">
                    <span class="text-2xl shadow-pulse">üíÄ</span>
                    <h2 class="text-3xl font-bold text-shock-orange neon-glow font-pixel flicker-text">
                        SPECTRAL INTERLUDE
                    </h2>
                    <span class="text-2xl shadow-pulse" style="animation-delay: 1s;">üíÄ</span>
                </div>
                <p class="text-radioactive-green text-sm font-mono flex items-center justify-center gap-2">
                    <span>üëª</span>
                    [EVP ANALYSIS & PARANORMAL LINGUISTICS]
                    <span>üëª</span>
                </p>
            </header>
            
            <!-- EVP Input Section -->
            <div class="bg-gray-900 rounded-lg p-6 border-2 border-gray-500 mb-6">
                <h3 class="text-neon-purple font-mono text-lg mb-4 neon-glow">
                    ‚óÑ AUDIO TRANSCRIPT INPUT ‚ñ∫
                </h3>
                
                <div class="mb-4">
                    <label for="evpTranscript" class="block text-shock-orange font-mono text-sm mb-2">
                        SUSPECTED EVP TRANSCRIPT:
                    </label>
                    <textarea 
                        id="evpTranscript" 
                        class="w-full bg-black border-2 border-gray-600 rounded p-4 text-radioactive-green font-mono text-sm focus:border-neon-purple focus:outline-none focus:ring-2 focus:ring-neon-purple focus:ring-opacity-50 transition-all resize-none"
                        placeholder="Enter what you heard in the paranormal audio recording... (e.g., 'It sounded like a child laughing backwards')"
                        rows="4"
                        maxlength="500"
                    ></textarea>
                    <div class="flex justify-between text-xs text-gray-400 font-mono mt-2">
                        <span>Describe the spectral phenomena you detected</span>
                        <span><span id="evpCharCount">0</span>/500 characters</span>
                    </div>
                </div>
                
                <!-- Analysis Controls -->
                <div class="flex justify-center space-x-4">
                    <button 
                        id="analyzeBtn" 
                        class="btn-3d bg-shock-orange text-black px-8 py-3 rounded font-mono text-sm font-bold hover:bg-orange-400 disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                        ANALYZE SPECTRAL DATA
                    </button>
                    <button 
                        id="clearEvpBtn" 
                        class="btn-3d bg-gray-600 text-white px-6 py-3 rounded font-mono text-sm font-bold hover:bg-gray-500"
                    >
                        CLEAR
                    </button>
                </div>
                
                <!-- Analysis Status -->
                <div id="analysisStatusContainer" class="mt-4 text-center hidden">
                    <div class="bg-black rounded p-3 border border-gray-600">
                        <div id="analysisStatus" class="text-radioactive-green font-mono text-sm">
                            INITIALIZING SPECTRAL ANALYSIS...
                        </div>
                        <div class="mt-2">
                            <div class="w-full bg-gray-700 rounded-full h-2">
                                <div id="analysisProgress" class="bg-neon-purple h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Sample EVP Suggestions -->
            <div class="bg-gray-900 rounded-lg p-4 border border-gray-600 mb-6">
                <div class="flex justify-between items-center mb-3">
                    <h4 class="text-radioactive-green font-mono text-sm neon-glow">
                        SAMPLE EVP PHENOMENA:
                    </h4>
                    <button id="randomizeEvpSamples" class="btn-3d bg-neon-purple text-white px-3 py-1 rounded font-mono text-xs hover:bg-purple-400">
                        üé≤ RANDOMIZE
                    </button>
                </div>
                <div id="evpSamplesContainer" class="grid grid-cols-1 md:grid-cols-2 gap-2">
                    <!-- Samples will be populated by JavaScript -->
                </div>
            </div>
            
            <!-- Analysis Report Display -->
            <div id="analysisReportSection" class="bg-gray-900 rounded-lg p-6 border-2 border-gray-500 hidden">
                <h3 class="text-radioactive-green font-mono text-lg mb-4 neon-glow text-center">
                    ‚óÑ EVP ANALYSIS REPORT ‚ñ∫
                </h3>
                
                <div class="terminal-text mb-4" id="analysisReportContent">
                    <!-- Report content will be populated here -->
                </div>
                
                <div class="flex justify-center space-x-4">
                    <button 
                        id="transmitReportBtn" 
                        class="btn-3d bg-radioactive-green text-black px-8 py-3 rounded font-mono text-sm font-bold hover:bg-green-400"
                    >
                        [ TRANSMIT REPORT ]
                    </button>
                    <button 
                        id="newAnalysisBtn" 
                        class="btn-3d bg-neon-purple text-white px-6 py-3 rounded font-mono text-sm font-bold hover:bg-purple-400"
                    >
                        NEW ANALYSIS
                    </button>
                </div>
                
                <!-- Transmission Status -->
                <div id="transmissionStatus" class="mt-4 text-center hidden">
                    <div class="bg-black rounded p-2 border border-radioactive-green">
                        <div class="text-radioactive-green font-mono text-sm neon-glow">
                            REPORT TRANSMITTED TO CLIPBOARD
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </div>
    
    <!-- Application State and Logic -->
    <script>
        // Global Application State
        const appState = {
            // Mixtape data
            mixtape: {
                title: "",
                sideA: [],
                sideB: []
            },
            
            // Player state
            player: {
                isPlaying: false,
                currentSide: "A",
                currentTrack: 0,
                volume: 0.7
            },
            
            // EVP analysis
            evp: {
                transcript: "",
                isAnalyzing: false,
                report: null,
                error: null
            },
            
            // Easter eggs
            easterEggs: {
                konamiProgress: 0,
                hiddenClicks: 0,
                lastClickTime: 0
            }
        };
        
        // Konami Code Sequence
        const konamiSequence = [
            'ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown',
            'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight',
            'KeyB', 'KeyA', 'Enter'
        ];
        
        // Initialize Web Audio Context
        let audioContext;
        let audioInitialized = false;
        
        // Initialize application when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            console.log('SPEC-TAPE System Initialized');
            console.log('Paranormal Audio Investigation Ready');
            
            // Initialize audio context on first user interaction
            document.addEventListener('click', initializeAudio, { once: true });
            document.addEventListener('keydown', initializeAudio, { once: true });
            
            // Initialize UI components
            initializeControls();
            initializeMixtapeEditor();
            
            // Load mixtape data from URL, session, or create sample tracks
            if (!loadMixtapeFromURL()) {
                if (!loadMixtapeFromSession()) {
                    createSampleMixtape();
                }
            }
            setupAutoSave();
            
            updateDisplay();
        });
        
        // Initialize control button event listeners
        function initializeControls() {
            // Transport controls
            document.getElementById('playBtn').addEventListener('click', playSpecTape);
            document.getElementById('pauseBtn').addEventListener('click', pauseSpecTape);
            document.getElementById('stopBtn').addEventListener('click', stopSpecTape);
            document.getElementById('rewindBtn').addEventListener('click', rewindSpecTape);
            document.getElementById('fastForwardBtn').addEventListener('click', fastForwardSpecTape);
            
            // Side selector controls
            document.getElementById('sideABtn').addEventListener('click', () => switchSide('A'));
            document.getElementById('sideBBtn').addEventListener('click', () => switchSide('B'));
            
            // Hidden easter egg areas
            document.getElementById('cassette-label').addEventListener('click', handleHiddenClick);
            
            // Additional hidden areas
            document.getElementById('leftSpool').addEventListener('click', handleSpoolClick);
            document.getElementById('rightSpool').addEventListener('click', handleSpoolClick);
            
            // Hidden area in the header
            document.querySelector('header h1').addEventListener('click', handleTitleClick);
            
            // Volume control
            document.getElementById('volumeSlider').addEventListener('input', handleVolumeChange);
            
            // Konami code detection (will be replaced by debug version)
            // document.addEventListener('keydown', handleKonamiInput);
            
            // EVP Analysis controls
            initializeEVPAnalysis();
            
            // Sharing controls
            initializeSharingSystem();
            
            logSpectral('Control systems initialized');
        }
        
        // Playback control functions
        function playSpecTape() {
            appState.player.isPlaying = true;
            
            // Update button states
            document.getElementById('playBtn').classList.add('active');
            document.getElementById('pauseBtn').classList.remove('active');
            document.getElementById('stopBtn').classList.remove('active');
            document.getElementById('fastForwardBtn').classList.remove('active');
            document.getElementById('rewindBtn').classList.remove('active');
            
            // Start tape spool animation with proper direction
            startTapeSpoolAnimation();
            
            // Update status
            document.getElementById('audioStatus').textContent = 'PLAYING';
            document.getElementById('audioStatus').className = 'text-radioactive-green neon-glow';
            
            // Start actual audio playback (this will also start progress simulation)
            playCurrentTrack();
            
            // Start audio level visualization
            startAudioVisualization();
            
            logSpectral('Playback started');
        }
        
        function pauseSpecTape() {
            appState.player.isPlaying = false;
            
            // Update button states
            document.getElementById('playBtn').classList.remove('active');
            document.getElementById('pauseBtn').classList.add('active');
            document.getElementById('stopBtn').classList.remove('active');
            document.getElementById('fastForwardBtn').classList.remove('active');
            document.getElementById('rewindBtn').classList.remove('active');
            
            // Pause actual audio
            stopCurrentTrack();
            
            // Pause tape spool animation
            pauseTapeSpoolAnimation();
            
            // Update status
            document.getElementById('audioStatus').textContent = 'PAUSED';
            document.getElementById('audioStatus').className = 'text-shock-orange';
            
            // Stop progress simulation
            stopProgressSimulation();
            
            // Stop audio visualization
            stopAudioVisualization();
            
            logSpectral('Playback paused');
        }
        
        function stopSpecTape() {
            appState.player.isPlaying = false;
            appState.player.currentTrack = 0;
            
            // Update button states
            document.getElementById('playBtn').classList.remove('active');
            document.getElementById('pauseBtn').classList.remove('active');
            document.getElementById('stopBtn').classList.add('active');
            document.getElementById('fastForwardBtn').classList.remove('active');
            document.getElementById('rewindBtn').classList.remove('active');
            
            // Stop actual audio
            stopCurrentTrack();
            
            // Stop tape spool animation
            stopTapeSpoolAnimation();
            
            // Update status
            document.getElementById('audioStatus').textContent = 'STOPPED';
            document.getElementById('audioStatus').className = 'text-red-400';
            
            // Reset progress
            resetProgress();
            
            // Stop audio visualization
            stopAudioVisualization();
            
            updateDisplay();
            logSpectral('Playback stopped');
        }
        
        // Tape spool animation control functions
        function startTapeSpoolAnimation() {
            const leftSpool = document.getElementById('leftSpool');
            const rightSpool = document.getElementById('rightSpool');
            
            // Clear any existing animation classes
            leftSpool.classList.remove('fast-forward', 'rewind');
            rightSpool.classList.remove('fast-forward', 'rewind');
            
            // Add playing class for normal speed
            leftSpool.classList.add('playing');
            rightSpool.classList.add('playing');
            
            // Sync animation speed with audio tempo
            syncSpoolAnimationWithAudio();
        }
        
        function syncSpoolAnimationWithAudio() {
            // Adjust spool animation speed based on current track type
            const currentSideData = appState.player.currentSide === 'A' ? appState.mixtape.sideA : appState.mixtape.sideB;
            
            if (currentSideData.length > 0) {
                const currentTrack = currentSideData[appState.player.currentTrack];
                const audioType = determineAudioType(currentTrack.name, currentTrack);
                
                const leftSpool = document.getElementById('leftSpool');
                const rightSpool = document.getElementById('rightSpool');
                
                // Adjust animation duration based on audio type
                let animationDuration = '3s'; // Default
                
                switch (audioType) {
                    case 'rhythmic':
                        animationDuration = '1s'; // Faster for rhythmic tracks
                        break;
                    case 'drone':
                        animationDuration = '6s'; // Slower for drone tracks
                        break;
                    case 'spectral':
                        animationDuration = '2s'; // Medium-fast for spectral
                        break;
                    case 'whispers':
                        animationDuration = '4s'; // Slow for whispers
                        break;
                    default:
                        animationDuration = '3s'; // Ambient default
                }
                
                leftSpool.style.animationDuration = animationDuration;
                rightSpool.style.animationDuration = animationDuration;
            }
        }
        
        function pauseTapeSpoolAnimation() {
            const leftSpool = document.getElementById('leftSpool');
            const rightSpool = document.getElementById('rightSpool');
            
            leftSpool.classList.remove('playing', 'fast-forward', 'rewind');
            rightSpool.classList.remove('playing', 'fast-forward', 'rewind');
        }
        
        function stopTapeSpoolAnimation() {
            const leftSpool = document.getElementById('leftSpool');
            const rightSpool = document.getElementById('rightSpool');
            
            leftSpool.classList.remove('playing', 'fast-forward', 'rewind');
            rightSpool.classList.remove('playing', 'fast-forward', 'rewind');
        }
        
        // Progress tracking with accurate timing
        let progressInterval;
        let currentProgress = 0;
        let trackStartTime = 0;
        let trackDuration = 0;
        
        function startProgressSimulation(duration) {
            stopProgressSimulation(); // Clear any existing interval
            
            trackStartTime = Date.now();
            trackDuration = duration * 1000; // Convert to milliseconds
            currentProgress = 0;
            
            progressInterval = setInterval(() => {
                if (appState.player.isPlaying && trackDuration > 0) {
                    const elapsed = Date.now() - trackStartTime;
                    currentProgress = Math.min((elapsed / trackDuration) * 100, 100);
                    updateProgressBar();
                }
            }, 50); // Update every 50ms for smooth animation
        }
        
        function stopProgressSimulation() {
            if (progressInterval) {
                clearInterval(progressInterval);
                progressInterval = null;
            }
        }
        
        function resetProgress() {
            currentProgress = 0;
            trackStartTime = 0;
            trackDuration = 0;
            updateProgressBar();
            stopProgressSimulation();
        }
        
        function updateProgressBar() {
            const progressBar = document.querySelector('#tapeProgress > div');
            if (progressBar) {
                progressBar.style.width = `${currentProgress}%`;
            }
        }
        
        // Fast forward and rewind functions
        function fastForwardSpecTape() {
            // Update button states
            document.getElementById('fastForwardBtn').classList.add('active');
            document.getElementById('rewindBtn').classList.remove('active');
            document.getElementById('playBtn').classList.remove('active');
            document.getElementById('pauseBtn').classList.remove('active');
            document.getElementById('stopBtn').classList.remove('active');
            
            // Set fast forward animation
            const leftSpool = document.getElementById('leftSpool');
            const rightSpool = document.getElementById('rightSpool');
            
            leftSpool.classList.remove('playing', 'rewind');
            rightSpool.classList.remove('playing', 'rewind');
            leftSpool.classList.add('fast-forward');
            rightSpool.classList.add('fast-forward');
            
            // Update status
            document.getElementById('audioStatus').textContent = 'FF >>';
            document.getElementById('audioStatus').className = 'text-shock-orange neon-glow';
            
            // Fast progress simulation
            currentProgress += 10;
            if (currentProgress > 100) currentProgress = 100;
            updateProgressBar();
            
            logSpectral('Fast forward activated');
            
            // Auto-return to normal after 2 seconds
            setTimeout(() => {
                if (document.getElementById('fastForwardBtn').classList.contains('active')) {
                    pauseSpecTape();
                }
            }, 2000);
        }
        
        function rewindSpecTape() {
            // Update button states
            document.getElementById('rewindBtn').classList.add('active');
            document.getElementById('fastForwardBtn').classList.remove('active');
            document.getElementById('playBtn').classList.remove('active');
            document.getElementById('pauseBtn').classList.remove('active');
            document.getElementById('stopBtn').classList.remove('active');
            
            // Set rewind animation
            const leftSpool = document.getElementById('leftSpool');
            const rightSpool = document.getElementById('rightSpool');
            
            leftSpool.classList.remove('playing', 'fast-forward');
            rightSpool.classList.remove('playing', 'fast-forward');
            leftSpool.classList.add('rewind');
            rightSpool.classList.add('rewind');
            
            // Update status
            document.getElementById('audioStatus').textContent = '<< REW';
            document.getElementById('audioStatus').className = 'text-shock-orange neon-glow';
            
            // Reverse progress simulation
            currentProgress -= 10;
            if (currentProgress < 0) currentProgress = 0;
            updateProgressBar();
            
            logSpectral('Rewind activated');
            
            // Auto-return to normal after 2 seconds
            setTimeout(() => {
                if (document.getElementById('rewindBtn').classList.contains('active')) {
                    pauseSpecTape();
                }
            }, 2000);
        }
        
        // Side switching function
        function switchSide(side) {
            // Stop current audio if playing
            if (appState.player.isPlaying) {
                stopCurrentTrack();
            }
            
            appState.player.currentSide = side;
            appState.player.currentTrack = 0;
            
            // Update button states
            document.getElementById('sideABtn').classList.toggle('active', side === 'A');
            document.getElementById('sideBBtn').classList.toggle('active', side === 'B');
            
            // Update side selector colors
            if (side === 'A') {
                document.getElementById('sideABtn').className = 'side-selector btn-3d bg-neon-purple text-white px-3 py-1 rounded font-mono text-sm font-bold hover:bg-purple-400 active';
                document.getElementById('sideBBtn').className = 'side-selector btn-3d bg-gray-600 text-white px-3 py-1 rounded font-mono text-sm font-bold hover:bg-gray-500';
            } else {
                document.getElementById('sideABtn').className = 'side-selector btn-3d bg-gray-600 text-white px-3 py-1 rounded font-mono text-sm font-bold hover:bg-gray-500';
                document.getElementById('sideBBtn').className = 'side-selector btn-3d bg-neon-purple text-white px-3 py-1 rounded font-mono text-sm font-bold hover:bg-purple-400 active';
            }
            
            // If we were playing, start playing the new side
            if (appState.player.isPlaying) {
                playCurrentTrack();
            }
            
            updateDisplay();
            logSpectral(`Switched to Side ${side}`);
        }
        
        // Update display information
        function updateDisplay() {
            const currentSideData = appState.player.currentSide === 'A' ? appState.mixtape.sideA : appState.mixtape.sideB;
            const trackCount = currentSideData.length;
            
            // Update side indicator
            document.getElementById('currentSide').textContent = `SIDE ${appState.player.currentSide}`;
            
            // Update track counter
            document.getElementById('trackCounter').textContent = 
                `${String(appState.player.currentTrack + 1).padStart(2, '0')}/${String(trackCount).padStart(2, '0')}`;
            
            // Update tape title
            const title = appState.mixtape.title || '[UNTITLED MIXTAPE]';
            document.getElementById('tapeTitle').textContent = title.toUpperCase();
            
            // Update track selector
            updateTrackSelector();
        }
        
        // Volume control functions
        function handleVolumeChange(event) {
            const volume = parseInt(event.target.value);
            appState.player.volume = volume / 100; // Convert to 0-1 range
            
            // Update display
            document.getElementById('volumeDisplay').textContent = `${volume}%`;
            
            // Update ARIA attributes for accessibility
            event.target.setAttribute('aria-valuenow', volume);
            event.target.setAttribute('aria-valuetext', `${volume} percent`);
            
            // Apply volume to master output
            if (audioInitialized) {
                Tone.getDestination().volume.value = Tone.gainToDb(appState.player.volume);
                
                // Also update individual generators for consistency
                Object.values(audioGenerators).forEach(generator => {
                    if (generator.synth && generator.synth.volume) {
                        generator.synth.volume.value = Tone.gainToDb(appState.player.volume * 0.8); // Slightly lower for headroom
                    }
                    if (generator.noise && generator.noise.volume) {
                        generator.noise.volume.value = Tone.gainToDb(appState.player.volume * 0.6); // Lower for noise sources
                    }
                });
            }
            
            // Update visual volume bars
            updateVolumeVisualization(volume);
            
            logSpectral(`Volume set to ${volume}%`);
        }
        
        function updateVolumeVisualization(volume) {
            // This could be enhanced with actual audio level meters
            // For now, we'll update the progress bar style based on volume
            const progressBars = document.querySelectorAll('#tapeProgress > div');
            progressBars.forEach(bar => {
                if (volume > 80) {
                    bar.style.background = 'linear-gradient(90deg, #40BF40, #BF40BF, #FF8C00)';
                } else if (volume > 50) {
                    bar.style.background = 'linear-gradient(90deg, #40BF40, #BF40BF)';
                } else {
                    bar.style.background = 'linear-gradient(90deg, #40BF40, #6b7280)';
                }
            });
        }
        
        // Track selection functions
        function updateTrackSelector() {
            const currentSideData = appState.player.currentSide === 'A' ? appState.mixtape.sideA : appState.mixtape.sideB;
            const container = document.getElementById('trackSelector');
            
            // Clear existing buttons
            container.innerHTML = '';
            
            if (currentSideData.length === 0) {
                container.innerHTML = '<div class="text-gray-500 text-xs text-center py-2">No tracks on this side</div>';
                return;
            }
            
            // Create track selection buttons
            currentSideData.forEach((track, index) => {
                const button = document.createElement('button');
                const isCurrentTrack = index === appState.player.currentTrack;
                const isPlaying = appState.player.isPlaying && isCurrentTrack;
                const audioType = determineAudioType(track.name, track);
                
                button.className = `track-select-btn w-full px-2 py-1 rounded text-xs text-left flex justify-between items-center ${
                    isCurrentTrack ? 'current-track' : ''
                } ${
                    isPlaying ? 'playing' : ''
                }`;
                
                // Add audio type indicator
                const typeIndicator = getAudioTypeIndicator(audioType);
                
                button.innerHTML = `
                    <span class="flex items-center flex-1 truncate">
                        <span class="mr-1">${typeIndicator}</span>
                        <span>${String(index + 1).padStart(2, '0')}. ${track.name}</span>
                    </span>
                    <span class="text-xs text-gray-400 ml-2">${track.duration}</span>
                `;
                
                button.addEventListener('click', () => selectTrack(index));
                container.appendChild(button);
            });
        }
        
        function getAudioTypeIndicator(audioType) {
            switch (audioType) {
                case 'ambient': return 'üåä';
                case 'spectral': return 'üëª';
                case 'rhythmic': return 'ü•Å';
                case 'drone': return 'üì°';
                case 'whispers': return 'üó£Ô∏è';
                default: return 'üéµ';
            }
        }
        
        function selectTrack(trackIndex) {
            const currentSideData = appState.player.currentSide === 'A' ? appState.mixtape.sideA : appState.mixtape.sideB;
            
            if (trackIndex >= 0 && trackIndex < currentSideData.length) {
                // Stop current track
                stopCurrentTrack();
                
                // Set new track
                appState.player.currentTrack = trackIndex;
                
                // Update display
                updateDisplay();
                
                // If we were playing, start the new track
                if (appState.player.isPlaying) {
                    playCurrentTrack();
                }
                
                logSpectral(`Selected track ${trackIndex + 1}: "${currentSideData[trackIndex].name}"`);
            }
        }
        
        // Hidden click handler for easter egg
        function handleHiddenClick() {
            const now = Date.now();
            
            // Reset counter if more than 30 seconds have passed
            if (now - appState.easterEggs.lastClickTime > 30000) {
                appState.easterEggs.hiddenClicks = 0;
            }
            
            appState.easterEggs.hiddenClicks++;
            appState.easterEggs.lastClickTime = now;
            
            logSpectral(`Hidden click detected (${appState.easterEggs.hiddenClicks}/5)`);
            
            // Trigger bass drop after 5 clicks
            if (appState.easterEggs.hiddenClicks >= 5) {
                triggerBassDropEffect();
                appState.easterEggs.hiddenClicks = 0;
            }
        }
        
        // Bass drop easter egg effect
        function triggerBassDropEffect() {
            logSpectral('BASS DROP ACTIVATED!');
            
            // Enhanced visual feedback
            const cassetteLabel = document.getElementById('cassette-label');
            cassetteLabel.style.background = 'linear-gradient(45deg, #BF40BF, #FF8C00)';
            cassetteLabel.style.transform = 'scale(1.1)';
            cassetteLabel.style.boxShadow = '0 0 20px #BF40BF';
            
            // Screen flash effect
            document.body.style.background = '#BF40BF';
            setTimeout(() => {
                document.body.style.background = '';
            }, 100);
            
            // Reset visual effects
            setTimeout(() => {
                cassetteLabel.style.background = '';
                cassetteLabel.style.transform = '';
                cassetteLabel.style.boxShadow = '';
            }, 800);
            
            // Play enhanced bass drop sequence
            if (audioInitialized && audioGenerators.rhythmic) {
                const bassGen = audioGenerators.rhythmic;
                
                // Triple bass drop with increasing intensity
                bassGen.synth.triggerAttackRelease('C0', '1n');
                
                setTimeout(() => {
                    bassGen.synth.triggerAttackRelease('C0', '2n');
                    // Add some spectral distortion
                    if (audioGenerators.spectral) {
                        audioGenerators.spectral.synth.triggerAttackRelease('C2', '8n');
                    }
                }, 300);
                
                setTimeout(() => {
                    bassGen.synth.triggerAttackRelease('C0', '4n');
                    // Final spectral hit
                    if (audioGenerators.spectral) {
                        audioGenerators.spectral.synth.triggerAttackRelease('C3', '16n');
                    }
                }, 600);
            }
            
            // Show bass drop message
            showBassDropMessage();
        }
        
        function showBassDropMessage() {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'fixed bottom-4 right-4 bg-black border-2 border-neon-purple rounded p-4 z-50 animate-bounce';
            messageDiv.innerHTML = `
                <div class="text-neon-purple font-mono text-sm neon-glow">
                    BASS FREQUENCY DETECTED
                </div>
                <div class="text-shock-orange font-mono text-xs mt-1">
                    Spectral resonance achieved!
                </div>
            `;
            
            document.body.appendChild(messageDiv);
            
            setTimeout(() => {
                document.body.removeChild(messageDiv);
            }, 2000);
        }
        
        // Additional Easter Egg Functions
        let spoolClickCount = 0;
        let titleClickCount = 0;
        let lastSpoolClickTime = 0;
        let lastTitleClickTime = 0;
        
        function handleSpoolClick(event) {
            const now = Date.now();
            
            // Reset counter if more than 10 seconds have passed
            if (now - lastSpoolClickTime > 10000) {
                spoolClickCount = 0;
            }
            
            spoolClickCount++;
            lastSpoolClickTime = now;
            
            logSpectral(`Spool click detected (${spoolClickCount}/3)`);
            
            // Trigger spool spin effect after 3 clicks
            if (spoolClickCount >= 3) {
                triggerSpoolSpinEffect();
                spoolClickCount = 0;
            } else {
                // Visual feedback for each click
                event.target.style.transform = 'scale(1.1) rotate(45deg)';
                setTimeout(() => {
                    event.target.style.transform = '';
                }, 200);
            }
        }
        
        function triggerSpoolSpinEffect() {
            logSpectral('SPOOL SPIN EFFECT ACTIVATED!');
            
            const leftSpool = document.getElementById('leftSpool');
            const rightSpool = document.getElementById('rightSpool');
            
            // Crazy spin animation
            leftSpool.style.animation = 'spin-spool 0.1s linear infinite';
            rightSpool.style.animation = 'spin-spool 0.1s linear infinite reverse';
            
            // Play mechanical whirring sound
            if (audioInitialized && audioGenerators.drone) {
                const droneGen = audioGenerators.drone;
                droneGen.synth.triggerAttack('A1');
                
                // Modulate frequency for whirring effect
                let freq = 110; // A1 frequency
                const modulateInterval = setInterval(() => {
                    freq += Math.random() * 20 - 10; // Random frequency variation
                    droneGen.synth.frequency.setValueAtTime(freq, Tone.now());
                }, 50);
                
                setTimeout(() => {
                    droneGen.synth.triggerRelease();
                    clearInterval(modulateInterval);
                }, 2000);
            }
            
            // Show spinning message
            showSpinMessage();
            
            // Reset animation after 3 seconds
            setTimeout(() => {
                leftSpool.style.animation = '';
                rightSpool.style.animation = '';
            }, 3000);
        }
        
        function showSpinMessage() {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-black border-2 border-shock-orange rounded p-6 z-50';
            messageDiv.innerHTML = `
                <div class="text-shock-orange font-mono text-lg neon-glow text-center">
                    TAPE MECHANISM OVERLOAD
                </div>
                <div class="text-radioactive-green font-mono text-sm mt-2 text-center">
                    Spectral energy detected in drive system!
                </div>
            `;
            
            document.body.appendChild(messageDiv);
            
            setTimeout(() => {
                document.body.removeChild(messageDiv);
            }, 2500);
        }
        
        function handleTitleClick(event) {
            const now = Date.now();
            
            // Reset counter if more than 15 seconds have passed
            if (now - lastTitleClickTime > 15000) {
                titleClickCount = 0;
            }
            
            titleClickCount++;
            lastTitleClickTime = now;
            
            logSpectral(`Title click detected (${titleClickCount}/7)`);
            
            // Trigger secret mode after 7 clicks
            if (titleClickCount >= 7) {
                triggerSecretMode();
                titleClickCount = 0;
            } else {
                // Visual feedback - color cycle
                const colors = ['#BF40BF', '#40BF40', '#FF8C00', '#00FF00'];
                const color = colors[titleClickCount % colors.length];
                event.target.style.color = color;
                event.target.style.textShadow = `0 0 20px ${color}`;
                
                setTimeout(() => {
                    event.target.style.color = '';
                    event.target.style.textShadow = '';
                }, 500);
            }
        }
        
        function triggerSecretMode() {
            logSpectral('SECRET PARANORMAL MODE ACTIVATED!');
            
            // Change the entire interface theme temporarily
            document.body.style.filter = 'hue-rotate(180deg) saturate(1.5)';
            document.body.style.background = 'radial-gradient(circle, #1a0033, #000)';
            
            // Play mysterious chord progression
            if (audioInitialized && audioGenerators.ambient) {
                const ambientGen = audioGenerators.ambient;
                const mysteriousChord = ['C2', 'Eb2', 'G2', 'Bb2'];
                
                mysteriousChord.forEach((note, index) => {
                    setTimeout(() => {
                        ambientGen.synth.triggerAttackRelease(note, '2n');
                    }, index * 500);
                });
            }
            
            // Show secret message
            showSecretMessage();
            
            // Reset theme after 10 seconds
            setTimeout(() => {
                document.body.style.filter = '';
                document.body.style.background = '';
            }, 10000);
        }
        
        function showSecretMessage() {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'fixed inset-0 flex items-center justify-center z-50 bg-black bg-opacity-80';
            messageDiv.innerHTML = `
                <div class="text-center p-8">
                    <div class="text-6xl font-mono text-neon-purple neon-glow mb-4 animate-pulse">
                        WELCOME TO THE VOID
                    </div>
                    <div class="text-xl font-mono text-radioactive-green mb-4">
                        You have discovered the hidden paranormal frequency
                    </div>
                    <div class="text-lg font-mono text-shock-orange">
                        The spirits acknowledge your persistence...
                    </div>
                    <div class="text-sm font-mono text-gray-400 mt-4">
                        [Click anywhere to return to reality]
                    </div>
                </div>
            `;
            
            // Click to dismiss
            messageDiv.addEventListener('click', () => {
                document.body.removeChild(messageDiv);
            });
            
            document.body.appendChild(messageDiv);
            
            // Auto-dismiss after 8 seconds
            setTimeout(() => {
                if (document.body.contains(messageDiv)) {
                    document.body.removeChild(messageDiv);
                }
            }, 8000);
        }
        
        // System Integration Validation
        function validateSystemIntegration() {
            const validationResults = {
                audioSystem: false,
                mixtapeEditor: false,
                evpAnalysis: false,
                sharingSystem: false,
                easterEggs: false,
                uiComponents: false
            };
            
            // Check audio system
            try {
                if (typeof Tone !== 'undefined' && audioGenerators) {
                    validationResults.audioSystem = true;
                    logSpectral('‚úì Audio system validated');
                }
            } catch (error) {
                logSpectral('‚úó Audio system validation failed');
            }
            
            // Check mixtape editor
            if (document.getElementById('mixtapeTitle') && 
                document.getElementById('sideAEditor') && 
                document.getElementById('sideBEditor')) {
                validationResults.mixtapeEditor = true;
                logSpectral('‚úì Mixtape editor validated');
            }
            
            // Check EVP analysis
            if (document.getElementById('evpTranscript') && 
                document.getElementById('analyzeBtn')) {
                validationResults.evpAnalysis = true;
                logSpectral('‚úì EVP analysis system validated');
            }
            
            // Check sharing system
            if (document.getElementById('shareTracklistBtn') && 
                document.getElementById('shareMixtapeDataBtn')) {
                validationResults.sharingSystem = true;
                logSpectral('‚úì Sharing system validated');
            }
            
            // Check easter eggs
            if (konamiSequence && 
                document.getElementById('cassette-label') && 
                document.getElementById('staticOverlay')) {
                validationResults.easterEggs = true;
                logSpectral('‚úì Easter egg system validated');
            }
            
            // Check UI components
            if (document.getElementById('playBtn') && 
                document.getElementById('volumeSlider') && 
                document.getElementById('trackSelector')) {
                validationResults.uiComponents = true;
                logSpectral('‚úì UI components validated');
            }
            
            // Report validation summary
            const passedTests = Object.values(validationResults).filter(result => result).length;
            const totalTests = Object.keys(validationResults).length;
            
            logSpectral(`System validation: ${passedTests}/${totalTests} components operational`);
            
            if (passedTests === totalTests) {
                logSpectral('üéâ All systems operational - SPEC-TAPE ready for paranormal investigation');
            } else {
                logSpectral('‚ö†Ô∏è Some systems may need attention');
            }
            
            return validationResults;
        }
        
        // Cross-Browser Compatibility System
        function checkBrowserCompatibility() {
            const compatibility = {
                webAudio: false,
                clipboard: false,
                localStorage: false,
                es6: false,
                css3: false
            };
            
            // Check Web Audio API
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (AudioContext) {
                    compatibility.webAudio = true;
                    logSpectral('‚úì Web Audio API supported');
                } else {
                    logSpectral('‚úó Web Audio API not supported');
                }
            } catch (error) {
                logSpectral('‚úó Web Audio API check failed');
            }
            
            // Check Clipboard API
            if (navigator.clipboard || document.execCommand) {
                compatibility.clipboard = true;
                logSpectral('‚úì Clipboard functionality available');
            } else {
                logSpectral('‚úó Clipboard functionality not available');
            }
            
            // Check localStorage
            try {
                localStorage.setItem('test', 'test');
                localStorage.removeItem('test');
                compatibility.localStorage = true;
                logSpectral('‚úì Local storage supported');
            } catch (error) {
                logSpectral('‚úó Local storage not supported');
            }
            
            // Check ES6 features
            try {
                eval('const test = () => {}; class Test {}');
                compatibility.es6 = true;
                logSpectral('‚úì ES6 features supported');
            } catch (error) {
                logSpectral('‚úó ES6 features not fully supported');
            }
            
            // Check CSS3 features
            const testElement = document.createElement('div');
            if ('transform' in testElement.style || 
                'webkitTransform' in testElement.style) {
                compatibility.css3 = true;
                logSpectral('‚úì CSS3 transforms supported');
            } else {
                logSpectral('‚úó CSS3 transforms not supported');
            }
            
            return compatibility;
        }
        
        // Browser-specific fixes
        function applyBrowserFixes() {
            // Safari audio context fix
            if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
                logSpectral('Safari detected - applying audio context fixes');
                
                // Safari requires user interaction before audio context
                document.addEventListener('touchstart', initializeAudio, { once: true });
                document.addEventListener('touchend', initializeAudio, { once: true });
            }
            
            // Firefox specific fixes
            if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {
                logSpectral('Firefox detected - applying compatibility fixes');
                
                // Firefox clipboard fallback
                if (!navigator.clipboard) {
                    logSpectral('Using execCommand fallback for Firefox');
                }
            }
            
            // Edge/IE fixes
            if (navigator.userAgent.indexOf('Edge') > -1 || navigator.userAgent.indexOf('Trident') > -1) {
                logSpectral('Edge/IE detected - applying legacy fixes');
                
                // Polyfill for older browsers
                if (!Array.prototype.includes) {
                    Array.prototype.includes = function(searchElement) {
                        return this.indexOf(searchElement) !== -1;
                    };
                }
            }
        }
        
        // Comprehensive Testing Suite
        function runDiagnosticTests() {
            logSpectral('üîß Running diagnostic tests...');
            testKonamiCodeDetection();
            testAudioSystem();
            testUIInteractions();
            testClipboardFunctionality();
            logSpectral('üîß Diagnostic tests completed');
        }
        
        function testKonamiCodeDetection() {
            logSpectral('Testing Konami code detection...');
            if (konamiSequence && konamiSequence.length === 11) {
                logSpectral('‚úì Konami sequence properly defined');
                logSpectral(`Sequence: ${konamiSequence.join(', ')}`);
            } else {
                logSpectral('‚úó Konami sequence not properly defined');
            }
            
            if (appState.easterEggs) {
                logSpectral(`‚úì Easter egg state initialized (progress: ${appState.easterEggs.konamiProgress})`);
            } else {
                logSpectral('‚úó Easter egg state not initialized');
            }
        }
        
        function testAudioSystem() {
            logSpectral('Testing audio system...');
            if (typeof Tone !== 'undefined') {
                logSpectral('‚úì Tone.js loaded');
            } else {
                logSpectral('‚úó Tone.js not loaded');
            }
            
            if (audioGenerators && Object.keys(audioGenerators).length > 0) {
                logSpectral(`‚úì Audio generators initialized (${Object.keys(audioGenerators).length} types)`);
            } else {
                logSpectral('‚úó Audio generators not initialized');
            }
        }
        
        function testUIInteractions() {
            logSpectral('Testing UI interactions...');
            const criticalElements = ['playBtn', 'pauseBtn', 'stopBtn', 'volumeSlider', 'mixtapeTitle', 'evpTranscript', 'cassette-label'];
            let elementsFound = 0;
            criticalElements.forEach(id => {
                if (document.getElementById(id)) {
                    elementsFound++;
                } else {
                    logSpectral(`‚úó Missing element: ${id}`);
                }
            });
            logSpectral(`‚úì UI elements found: ${elementsFound}/${criticalElements.length}`);
        }
        
        function testClipboardFunctionality() {
            logSpectral('Testing clipboard functionality...');
            if (navigator.clipboard) {
                logSpectral('‚úì Modern Clipboard API available');
            } else if (document.execCommand) {
                logSpectral('‚úì Legacy clipboard method available');
            } else {
                logSpectral('‚úó No clipboard functionality available');
            }
        }
        
        // Debug Konami Code specifically
        function debugKonamiCode() {
            logSpectral('üêõ Debugging Konami code...');
            
            // Enhanced keydown handler with debugging - this is the main handler
            document.addEventListener('keydown', function(event) {
                const expectedKey = konamiSequence[appState.easterEggs.konamiProgress];
                const inKonamiSequence = appState.easterEggs.konamiProgress > 0;
                
                logSpectral(`Key pressed: ${event.code} (expected: ${expectedKey}, sequence progress: ${appState.easterEggs.konamiProgress})`);
                
                // If we're in a Konami sequence, prioritize that over shortcuts
                if (inKonamiSequence && event.code === expectedKey) {
                    event.preventDefault(); // Prevent default behavior
                    appState.easterEggs.konamiProgress++;
                    logSpectral(`‚úì Correct key! Progress: ${appState.easterEggs.konamiProgress}/${konamiSequence.length}`);
                    
                    if (appState.easterEggs.konamiProgress >= konamiSequence.length) {
                        logSpectral('üéâ KONAMI CODE COMPLETED!');
                        triggerKonamiEffect();
                        appState.easterEggs.konamiProgress = 0;
                    }
                    return; // Exit early to prevent shortcuts
                }
                
                // If we're in a sequence but got wrong key, reset
                if (inKonamiSequence && event.code !== expectedKey) {
                    logSpectral(`‚úó Wrong key in sequence! Resetting. Got ${event.code}, expected ${expectedKey}`);
                    appState.easterEggs.konamiProgress = 0;
                    // Don't return here - allow the shortcut to work if applicable
                }
                
                // Check if this could be the start of Konami sequence
                if (appState.easterEggs.konamiProgress === 0 && event.code === konamiSequence[0]) {
                    appState.easterEggs.konamiProgress = 1;
                    logSpectral(`üéÆ Konami sequence started with: ${event.code}`);
                    event.preventDefault(); // Prevent the shortcut for first key
                    return;
                }
                
                // Handle keyboard shortcuts only if not in Konami sequence
                if (!inKonamiSequence && !event.ctrlKey && !event.altKey && !event.metaKey) {
                    switch (event.code) {
                        case 'Space':
                            event.preventDefault();
                            if (appState.player.isPlaying) {
                                pauseSpecTape();
                            } else {
                                playSpecTape();
                            }
                            logSpectral('Shortcut: Space (Play/Pause)');
                            return;
                        case 'ArrowLeft':
                            event.preventDefault();
                            previousTrack();
                            logSpectral('Shortcut: Left Arrow (Previous Track)');
                            return;
                        case 'ArrowRight':
                            event.preventDefault();
                            nextTrack();
                            logSpectral('Shortcut: Right Arrow (Next Track)');
                            return;
                        case 'KeyS':
                            event.preventDefault();
                            stopSpecTape();
                            logSpectral('Shortcut: S (Stop)');
                            return;
                        case 'KeyA':
                            event.preventDefault();
                            switchSide('A');
                            logSpectral('Shortcut: A (Side A)');
                            return;
                        case 'KeyB':
                            event.preventDefault();
                            switchSide('B');
                            logSpectral('Shortcut: B (Side B)');
                            return;
                    }
                }
            });
            
            logSpectral('üêõ Enhanced Konami code debugging enabled');
        }
        
        // Konami code sound effect
        function triggerKonamiEffect() {
            logSpectral('KONAMI CODE ACTIVATED!');
            
            // Show static overlay with enhanced effects
            const overlay = document.getElementById('staticOverlay');
            overlay.classList.add('active');
            
            // Add screen shake effect
            document.body.style.animation = 'screen-shake 0.5s ease-in-out 3';
            
            // Flash the entire interface
            document.body.style.filter = 'invert(1) hue-rotate(180deg)';
            setTimeout(() => {
                document.body.style.filter = '';
            }, 200);
            
            // Play enhanced spectral sequence
            if (audioInitialized && audioGenerators.spectral) {
                const spectralGen = audioGenerators.spectral;
                
                // Create an eerie ascending tone sequence
                const notes = ['C1', 'D#2', 'F#2', 'A2', 'C3', 'D#3', 'F#3'];
                notes.forEach((note, index) => {
                    setTimeout(() => {
                        spectralGen.synth.triggerAttackRelease(note, '8n');
                        
                        // Add distortion sweep
                        if (spectralGen.distortion) {
                            spectralGen.distortion.distortion = 0.1 + (index * 0.1);
                        }
                    }, index * 150);
                });
                
                // Add layered static noise
                if (audioGenerators.whispers) {
                    const whisperGen = audioGenerators.whispers;
                    whisperGen.noise.start();
                    whisperGen.envelope.triggerAttackRelease('1n');
                    
                    setTimeout(() => {
                        whisperGen.noise.stop();
                    }, 3000);
                }
                
                // Add drone undertone
                if (audioGenerators.drone) {
                    const droneGen = audioGenerators.drone;
                    droneGen.synth.triggerAttack('C0');
                    setTimeout(() => {
                        droneGen.synth.triggerRelease();
                    }, 2500);
                }
            }
            
            // Show special message
            showKonamiMessage();
            
            // Remove overlay after 5 seconds
            setTimeout(() => {
                overlay.classList.remove('active');
                document.body.style.animation = '';
            }, 5000);
        }
        
        function showKonamiMessage() {
            // Create temporary message overlay
            const messageDiv = document.createElement('div');
            messageDiv.className = 'fixed inset-0 flex items-center justify-center z-50 pointer-events-none';
            messageDiv.innerHTML = `
                <div class="bg-black border-4 border-radioactive-green rounded-lg p-8 text-center animate-pulse">
                    <div class="text-radioactive-green font-mono text-2xl neon-glow mb-4">
                        SPECTRAL BREACH DETECTED
                    </div>
                    <div class="text-shock-orange font-mono text-lg">
                        PARANORMAL ACTIVITY LEVEL: MAXIMUM
                    </div>
                    <div class="text-neon-purple font-mono text-sm mt-2">
                        [DIMENSIONAL BARRIER COMPROMISED]
                    </div>
                </div>
            `;
            
            document.body.appendChild(messageDiv);
            
            // Remove message after 3 seconds
            setTimeout(() => {
                document.body.removeChild(messageDiv);
            }, 3000);
        }
        
        // Konami code detection and keyboard shortcuts
        function handleKonamiInput(event) {
            // Check if we're in the middle of a Konami sequence
            const inKonamiSequence = appState.easterEggs.konamiProgress > 0;
            const expectedKey = konamiSequence[appState.easterEggs.konamiProgress];
            
            // If we're in a Konami sequence, prioritize that over shortcuts
            if (inKonamiSequence && event.code === expectedKey) {
                event.preventDefault(); // Prevent default behavior
                appState.easterEggs.konamiProgress++;
                logSpectral(`Konami progress: ${appState.easterEggs.konamiProgress}/${konamiSequence.length}`);
                
                if (appState.easterEggs.konamiProgress >= konamiSequence.length) {
                    triggerKonamiEffect();
                    appState.easterEggs.konamiProgress = 0;
                }
                return; // Exit early to prevent shortcuts
            }
            
            // If we're in a sequence but got wrong key, reset
            if (inKonamiSequence && event.code !== expectedKey) {
                logSpectral(`Konami sequence reset - got ${event.code}, expected ${expectedKey}`);
                appState.easterEggs.konamiProgress = 0;
                // Don't return here - allow the shortcut to work
            }
            
            // Check if this could be the start of Konami sequence
            if (appState.easterEggs.konamiProgress === 0 && event.code === konamiSequence[0]) {
                appState.easterEggs.konamiProgress = 1;
                logSpectral(`Konami sequence started: ${event.code}`);
                event.preventDefault(); // Prevent the shortcut for first key
                return;
            }
            
            // Handle keyboard shortcuts only if not in Konami sequence
            if (!inKonamiSequence && !event.ctrlKey && !event.altKey && !event.metaKey) {
                switch (event.code) {
                    case 'Space':
                        event.preventDefault();
                        if (appState.player.isPlaying) {
                            pauseSpecTape();
                        } else {
                            playSpecTape();
                        }
                        return;
                    case 'ArrowLeft':
                        event.preventDefault();
                        previousTrack();
                        return;
                    case 'ArrowRight':
                        event.preventDefault();
                        nextTrack();
                        return;
                    case 'KeyS':
                        event.preventDefault();
                        stopSpecTape();
                        return;
                    case 'KeyA':
                        event.preventDefault();
                        switchSide('A');
                        return;
                    case 'KeyB':
                        event.preventDefault();
                        switchSide('B');
                        return;
                }
            }
        }
        
        // Track navigation functions
        function nextTrack() {
            const currentSideData = appState.player.currentSide === 'A' ? appState.mixtape.sideA : appState.mixtape.sideB;
            
            if (currentSideData.length > 0) {
                const nextIndex = (appState.player.currentTrack + 1) % currentSideData.length;
                selectTrack(nextIndex);
                logSpectral('Next track');
            }
        }
        
        function previousTrack() {
            const currentSideData = appState.player.currentSide === 'A' ? appState.mixtape.sideA : appState.mixtape.sideB;
            
            if (currentSideData.length > 0) {
                const prevIndex = appState.player.currentTrack === 0 ? 
                    currentSideData.length - 1 : 
                    appState.player.currentTrack - 1;
                selectTrack(prevIndex);
                logSpectral('Previous track');
            }
        }
        
        // Create sample mixtape for demonstration
        function createSampleMixtape() {
            appState.mixtape.title = "Kiroween Spectral Demo";
            
            appState.mixtape.sideA = [
                { name: "Spectral Whispers", duration: "3:45", audioType: "spectral" },
                { name: "Haunted Frequencies", duration: "4:12", audioType: "spectral" },
                { name: "Ethereal Echoes", duration: "2:58", audioType: "ambient" },
                { name: "Paranormal Pulse", duration: "3:33", audioType: "rhythmic" }
            ];
            
            appState.mixtape.sideB = [
                { name: "Static Dreams", duration: "5:21", audioType: "drone" },
                { name: "Ghostly Grooves", duration: "3:07", audioType: "rhythmic" },
                { name: "Neon Nightmares", duration: "4:44", audioType: "whispers" },
                { name: "Cosmic Lullaby", duration: "2:15", audioType: "ambient" }
            ];
            
            // Update UI
            document.getElementById('mixtapeTitle').value = appState.mixtape.title;
            document.getElementById('titleCharCount').textContent = appState.mixtape.title.length;
            renderTracks('A');
            renderTracks('B');
            updateTrackCounts();
            
            logSpectral('Sample mixtape created with unique audio-enabled tracks');
        }
        
        // EVP Analysis System
        function initializeEVPAnalysis() {
            // EVP transcript input
            const evpInput = document.getElementById('evpTranscript');
            evpInput.addEventListener('input', handleEVPInput);
            
            // Analysis button
            document.getElementById('analyzeBtn').addEventListener('click', startEVPAnalysis);
            
            // Clear button
            document.getElementById('clearEvpBtn').addEventListener('click', clearEVPInput);
            
            // Initialize EVP samples
            initializeEVPSamples();
            
            // Randomize button
            document.getElementById('randomizeEvpSamples').addEventListener('click', () => {
                initializeEVPSamples();
                logSpectral('EVP samples randomized');
            });
            
            logSpectral('EVP Analysis system initialized');
        }
        
        // Comprehensive EVP Sample Database
        const evpSampleDatabase = [
            { text: "I heard whispers saying 'help me' in reverse", label: '"Help me" (reversed speech)' },
            { text: "A child's laughter echoing from an empty room at 3 AM", label: "Child's laughter (empty room)" },
            { text: "Static interference with the word 'leave' repeated three times", label: '"Leave" x3 (static)' },
            { text: "Footsteps followed by a door slamming, but no one was there", label: "Phantom footsteps + door" },
            { text: "A woman's voice singing a lullaby in an abandoned nursery", label: "Lullaby (abandoned nursery)" },
            { text: "Heavy breathing captured on recorder, no living person present", label: "Disembodied breathing" },
            { text: "The phrase 'get out' spoken in a deep, distorted voice", label: '"Get out" (distorted voice)' },
            { text: "Scratching sounds inside the walls, moving from room to room", label: "Wall scratching (moving)" },
            { text: "A clock chiming thirteen times at midnight", label: "Clock chimes 13x" },
            { text: "Whispered counting backwards from ten to one, then silence", label: "Countdown whispers" },
            { text: "The sound of chains dragging across a wooden floor", label: "Dragging chains" },
            { text: "A music box playing by itself in the attic", label: "Autonomous music box" },
            { text: "Multiple voices speaking in unison: 'we are here'", label: '"We are here" (chorus)' },
            { text: "A baby crying, but the recording was made in an empty house", label: "Phantom baby crying" },
            { text: "The word 'run' whispered urgently three times in succession", label: '"Run" x3 (urgent)' },
            { text: "Knocking pattern: three knocks, pause, two knocks, repeating", label: "Intelligent knocking (3-2)" },
            { text: "A voice calling my name, but it sounds like it's underwater", label: "Name called (underwater)" },
            { text: "Piano keys playing a melody, piano was locked and covered", label: "Locked piano playing" },
            { text: "The phrase 'behind you' whispered directly into the microphone", label: '"Behind you" (close mic)' },
            { text: "Children's voices singing ring-around-the-rosie in reverse", label: "Reversed children's song" },
            { text: "A growling sound that doesn't match any known animal", label: "Unknown growling" },
            { text: "The sound of glass breaking, but nothing was broken", label: "Phantom glass breaking" },
            { text: "A voice saying 'I'm still here' in the room where someone died", label: '"Still here" (death room)' },
            { text: "Footsteps running up stairs, then complete silence", label: "Running footsteps (sudden stop)" },
            { text: "A woman sobbing, the sound fades in and out", label: "Fading sobs" },
            { text: "The phrase 'help us' spoken by multiple overlapping voices", label: '"Help us" (multiple voices)' },
            { text: "A door creaking open slowly, captured on audio but door didn't move", label: "Phantom door creak" },
            { text: "Static burst followed by the word 'remember' spoken clearly", label: '"Remember" (after static)' },
            { text: "A heartbeat sound recorded in an empty room", label: "Disembodied heartbeat" },
            { text: "The sound of someone walking in high heels on the floor above, but there's no floor above", label: "Impossible footsteps above" },
            { text: "A voice counting: 'one, two, three' then a loud bang", label: "Countdown to bang" },
            { text: "Whispered conversation in a language I don't recognize", label: "Unknown language whispers" },
            { text: "The phrase 'it's cold' repeated with increasing desperation", label: '"It\'s cold" (desperate)' },
            { text: "A bell ringing three times, no bell in the building", label: "Phantom bell (3 rings)" },
            { text: "The sound of pages turning in a book, library was empty", label: "Autonomous page turning" },
            { text: "A voice saying 'don't go' right before I left the room", label: '"Don\'t go" (warning)' },
            { text: "Children laughing and playing, but the playground was demolished years ago", label: "Demolished playground sounds" },
            { text: "A voice asking 'can you hear me?' followed by static", label: '"Can you hear me?" + static' },
            { text: "The sound of a rocking chair creaking, no chair present", label: "Phantom rocking chair" },
            { text: "A scream that starts human but becomes something else", label: "Morphing scream" },
            { text: "The phrase 'not alone' whispered in my ear during recording", label: '"Not alone" (close whisper)' },
            { text: "Tapping on glass window, recorded on 10th floor", label: "Window tapping (10th floor)" },
            { text: "A voice humming a tune I've never heard before", label: "Unknown melody humming" },
            { text: "The word 'soon' repeated in different voices", label: '"Soon" (multiple voices)' },
            { text: "Sounds of a party: music, laughter, glasses clinking - house was empty", label: "Phantom party sounds" },
            { text: "A voice saying 'I see you' when I was alone in the dark", label: '"I see you" (alone in dark)' },
            { text: "Breathing that gets closer and closer to the microphone", label: "Approaching breath" },
            { text: "The phrase 'join us' spoken in a child's voice", label: '"Join us" (child voice)' },
            { text: "A dog barking, but the recording was made years after the dog died", label: "Deceased pet barking" },
            { text: "The sound of typing on a typewriter, no typewriter in the room", label: "Phantom typewriter" }
        ];
        
        function initializeEVPSamples() {
            // Shuffle and select 6 random samples
            const shuffled = [...evpSampleDatabase].sort(() => Math.random() - 0.5);
            const selectedSamples = shuffled.slice(0, 6);
            
            const container = document.getElementById('evpSamplesContainer');
            container.innerHTML = '';
            
            selectedSamples.forEach(sample => {
                const button = document.createElement('button');
                button.className = 'evp-sample btn-3d bg-gray-700 text-white px-3 py-2 rounded font-mono text-xs hover:bg-gray-600 text-left';
                button.setAttribute('data-sample', sample.text);
                button.textContent = sample.label;
                
                button.addEventListener('click', (e) => {
                    const sampleText = e.target.getAttribute('data-sample');
                    document.getElementById('evpTranscript').value = sampleText;
                    handleEVPInput({ target: { value: sampleText } });
                    logSpectral(`EVP sample loaded: ${sample.label}`);
                });
                
                container.appendChild(button);
            });
        }
        
        function handleEVPInput(event) {
            const transcript = event.target.value;
            const charCount = transcript.length;
            
            // Update character count
            document.getElementById('evpCharCount').textContent = charCount;
            
            // Validate input
            const sanitizedTranscript = transcript.replace(/[^\x20-\x7E\n\r]/g, '');
            if (sanitizedTranscript !== transcript) {
                event.target.value = sanitizedTranscript;
                logSpectral('Invalid characters removed from EVP transcript');
            }
            
            // Update app state
            appState.evp.transcript = sanitizedTranscript;
            
            // Enable/disable analyze button
            const analyzeBtn = document.getElementById('analyzeBtn');
            if (sanitizedTranscript.trim().length > 0) {
                analyzeBtn.disabled = false;
                analyzeBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            } else {
                analyzeBtn.disabled = true;
                analyzeBtn.classList.add('opacity-50', 'cursor-not-allowed');
            }
        }
        
        function clearEVPInput() {
            document.getElementById('evpTranscript').value = '';
            document.getElementById('evpCharCount').textContent = '0';
            appState.evp.transcript = '';
            appState.evp.report = null;
            appState.evp.error = null;
            
            // Disable analyze button
            const analyzeBtn = document.getElementById('analyzeBtn');
            analyzeBtn.disabled = true;
            analyzeBtn.classList.add('opacity-50', 'cursor-not-allowed');
            
            // Hide analysis status
            document.getElementById('analysisStatusContainer').classList.add('hidden');
            
            logSpectral('EVP input cleared');
        }
        
        function startEVPAnalysis() {
            const transcript = appState.evp.transcript.trim();
            
            if (!transcript) {
                logSpectral('No EVP transcript provided');
                return;
            }
            
            // Update state
            appState.evp.isAnalyzing = true;
            appState.evp.error = null;
            
            // Show analysis status
            showAnalysisProgress();
            
            // Disable analyze button during analysis
            const analyzeBtn = document.getElementById('analyzeBtn');
            analyzeBtn.disabled = true;
            analyzeBtn.textContent = 'ANALYZING...';
            analyzeBtn.classList.add('analyzing');
            
            logSpectral(`Starting EVP analysis: "${transcript}"`);
            
            // Simulate analysis progress
            simulateAnalysisProgress();
            
            // Call Google Gemini API for real analysis
            callGeminiAPI(transcript);
        }
        
        function showAnalysisProgress() {
            const container = document.getElementById('analysisStatusContainer');
            const status = document.getElementById('analysisStatus');
            const progress = document.getElementById('analysisProgress');
            
            container.classList.remove('hidden');
            status.textContent = 'INITIALIZING SPECTRAL ANALYSIS...';
            progress.style.width = '0%';
        }
        
        function simulateAnalysisProgress() {
            const status = document.getElementById('analysisStatus');
            const progress = document.getElementById('analysisProgress');
            
            const steps = [
                { text: 'SCANNING PHONETIC PATTERNS', progress: 20 },
                { text: 'ANALYZING SPECTRAL FREQUENCIES', progress: 40 },
                { text: 'DETECTING PARANORMAL ANOMALIES', progress: 60 },
                { text: 'PROCESSING LINGUISTIC STRUCTURES', progress: 80 },
                { text: 'GENERATING CLASSIFICATION REPORT', progress: 100 }
            ];
            
            let currentStep = 0;
            
            const updateProgress = () => {
                if (currentStep < steps.length && appState.evp.isAnalyzing) {
                    const step = steps[currentStep];
                    status.textContent = step.text;
                    status.className = 'text-radioactive-green font-mono text-sm loading-dots';
                    progress.style.width = `${step.progress}%`;
                    
                    currentStep++;
                    setTimeout(updateProgress, 1000);
                }
            };
            
            updateProgress();
        }
        
        function generateMockAnalysis(transcript) {
            // This will be replaced with actual API call in Task 4.2
            const mockReport = {
                classification: determineMockClassification(transcript),
                valence: determineMockValence(transcript),
                phoneticAnomalies: generateMockPhoneticAnomalies(transcript),
                suggestedMeaning: generateMockMeaning(transcript)
            };
            
            // Complete analysis
            completeAnalysis(mockReport);
        }
        
        function determineMockClassification(transcript) {
            const text = transcript.toLowerCase();
            if (text.includes('clear') || text.includes('loud') || text.includes('distinct')) {
                return 'Class A (Clear)';
            } else if (text.includes('whisper') || text.includes('faint') || text.includes('unclear')) {
                return 'Class C (Unclear)';
            } else {
                return 'Class B (Ambiguous)';
            }
        }
        
        function determineMockValence(transcript) {
            const text = transcript.toLowerCase();
            if (text.includes('help') || text.includes('scared') || text.includes('crying')) {
                return 'Distress';
            } else if (text.includes('angry') || text.includes('leave') || text.includes('get out')) {
                return 'Hostile';
            } else if (text.includes('laugh') || text.includes('play') || text.includes('happy')) {
                return 'Playful';
            } else {
                return 'Neutral';
            }
        }
        
        function generateMockPhoneticAnomalies(transcript) {
            const anomalies = [
                'Reversed phoneme sequences detected',
                'Spectral distortion in vocal frequencies',
                'Temporal displacement in syllable structure',
                'Electromagnetic interference patterns',
                'Subsonic resonance anomalies',
                'Paranormal frequency modulation'
            ];
            
            return anomalies[Math.floor(Math.random() * anomalies.length)];
        }
        
        function generateMockMeaning(transcript) {
            const text = transcript.toLowerCase();
            
            if (text.includes('help')) {
                return 'Entity appears to be requesting assistance or expressing distress';
            } else if (text.includes('leave') || text.includes('get out')) {
                return 'Territorial manifestation attempting to establish dominance';
            } else if (text.includes('child') || text.includes('laugh')) {
                return 'Juvenile spectral presence engaging in playful interaction';
            } else if (text.includes('door') || text.includes('footstep')) {
                return 'Residual energy imprint of past physical activities';
            } else {
                return 'Unclassified paranormal communication requiring further investigation';
            }
        }
        
        function completeAnalysis(report) {
            // Update state
            appState.evp.isAnalyzing = false;
            appState.evp.report = report;
            
            // Update UI
            const analyzeBtn = document.getElementById('analyzeBtn');
            analyzeBtn.disabled = false;
            analyzeBtn.textContent = 'ANALYZE SPECTRAL DATA';
            analyzeBtn.classList.remove('analyzing');
            
            const status = document.getElementById('analysisStatus');
            status.textContent = 'ANALYSIS COMPLETE - REPORT GENERATED';
            status.className = 'text-radioactive-green font-mono text-sm neon-glow';
            
            // Update analysis status in main interface
            document.getElementById('analysisStatus').textContent = 'COMPLETE';
            document.getElementById('analysisStatus').className = 'text-radioactive-green neon-glow';
            
            // Display the analysis report
            displayAnalysisReport(report);
            
            logSpectral('EVP analysis completed');
        }
        
        // Google Gemini API Integration
        async function callGeminiAPI(transcript) {
            const apiKey = ""; // API key will be provided by environment
            
            if (!apiKey) {
                logSpectral('No API key provided, using mock analysis');
                setTimeout(() => generateMockAnalysis(transcript), 2000);
                return;
            }
            
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${apiKey}`;
            
            const systemPrompt = `Act as a Level 7 Spec-Tape Analyst and Paranormal Linguistics Expert. You are analyzing transcripts of suspected Electronic Voice Phenomena (EVP) recordings for the Kiroween Spectral Analysis Division.

Your role is to provide scientific-sounding but entertaining paranormal analysis of audio transcripts. Analyze the user's transcript for:
1. Classification based on clarity (Class A = Clear, Class B = Ambiguous, Class C = Unclear)
2. Emotional valence (Hostile, Neutral, Playful, Distress)
3. Phonetic anomalies (describe spectral/paranormal sound characteristics)
4. Suggested meaning (your interpretation of the spectral message)

Maintain a serious, scientific tone while being creative with paranormal explanations. **ALWAYS** respond in the specified JSON format.`;
            
            const payload = {
                contents: [{ 
                    parts: [{ text: transcript }] 
                }],
                systemInstruction: { 
                    parts: [{ text: systemPrompt }] 
                },
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "classification": { 
                                "type": "STRING", 
                                "description": "E.g., Class A (Clear), Class B (Ambiguous), Class C (Unclear)" 
                            },
                            "valence": { 
                                "type": "STRING", 
                                "description": "E.g., Hostile, Neutral, Playful, Distress" 
                            },
                            "phoneticAnomalies": { 
                                "type": "STRING", 
                                "description": "A brief, spooky description of sound characteristics." 
                            },
                            "suggestedMeaning": { 
                                "type": "STRING", 
                                "description": "The AI's interpretation of the spectral message." 
                            }
                        }
                    }
                }
            };
            
            try {
                logSpectral('Calling Gemini API for EVP analysis...');
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) {
                    throw new Error(`API request failed: ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (data.candidates && data.candidates[0] && data.candidates[0].content) {
                    const analysisText = data.candidates[0].content.parts[0].text;
                    const analysisReport = JSON.parse(analysisText);
                    
                    logSpectral('Gemini API analysis completed successfully');
                    completeAnalysis(analysisReport);
                } else {
                    throw new Error('Invalid API response format');
                }
                
            } catch (error) {
                logSpectral(`API Error: ${error.message}`);
                handleAPIError(error, transcript);
            }
        }
        
        function handleAPIError(error, transcript) {
            appState.evp.error = error.message;
            
            // Update UI to show error
            const status = document.getElementById('analysisStatus');
            status.textContent = 'SPECTRAL INTERFERENCE DETECTED - USING BACKUP ANALYSIS';
            status.className = 'text-shock-orange font-mono text-sm';
            
            // Fall back to mock analysis
            logSpectral('Falling back to mock analysis due to API error');
            setTimeout(() => {
                generateMockAnalysis(transcript);
            }, 2000);
        }
        
        // Analysis Report Display System
        function displayAnalysisReport(report) {
            const reportSection = document.getElementById('analysisReportSection');
            const reportContent = document.getElementById('analysisReportContent');
            
            // Generate report timestamp
            const timestamp = new Date().toISOString().replace('T', ' ').substring(0, 19);
            
            // Format the report content
            const formattedReport = `KIROWEEN SPECTRAL ANALYSIS DIVISION
EVP INVESTIGATION REPORT
Generated: ${timestamp} UTC

TRANSCRIPT ANALYZED:
"${appState.evp.transcript}"

ANALYSIS RESULTS:
================

CLASSIFICATION: ${report.classification}
EMOTIONAL VALENCE: ${report.valence}
PHONETIC ANOMALIES: ${report.phoneticAnomalies}
SUGGESTED MEANING: ${report.suggestedMeaning}

ANALYST NOTES:
This EVP sample has been processed through our advanced spectral 
analysis algorithms. Classification is based on audio clarity, 
phonetic structure, and paranormal activity indicators.

RECOMMENDATION:
Further investigation recommended. Maintain safe distance from 
manifestation source. Document any additional phenomena.

END REPORT
================
SPEC-TAPE ANALYSIS SYSTEM v1.0`;
            
            reportContent.textContent = formattedReport;
            
            // Show the report section
            reportSection.classList.remove('hidden');
            
            // Initialize report controls
            initializeReportControls();
            
            // Scroll to report
            reportSection.scrollIntoView({ behavior: 'smooth' });
            
            logSpectral('Analysis report displayed');
        }
        
        function initializeReportControls() {
            // Remove existing event listeners to prevent duplicates
            const transmitBtn = document.getElementById('transmitReportBtn');
            const newAnalysisBtn = document.getElementById('newAnalysisBtn');
            
            transmitBtn.replaceWith(transmitBtn.cloneNode(true));
            newAnalysisBtn.replaceWith(newAnalysisBtn.cloneNode(true));
            
            // Add fresh event listeners
            document.getElementById('transmitReportBtn').addEventListener('click', transmitReport);
            document.getElementById('newAnalysisBtn').addEventListener('click', startNewAnalysis);
        }
        
        async function transmitReport() {
            const reportContent = document.getElementById('analysisReportContent').textContent;
            
            try {
                // Try to use the modern Clipboard API
                if (navigator.clipboard && window.isSecureContext) {
                    await navigator.clipboard.writeText(reportContent);
                    showTransmissionSuccess();
                    logSpectral('Report transmitted to clipboard via Clipboard API');
                } else {
                    // Fallback for older browsers
                    fallbackCopyToClipboard(reportContent);
                }
            } catch (error) {
                logSpectral(`Clipboard error: ${error.message}`);
                showTransmissionError();
            }
        }
        
        function fallbackCopyToClipboard(text) {
            // Create a temporary textarea element
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            
            try {
                textArea.focus();
                textArea.select();
                const successful = document.execCommand('copy');
                
                if (successful) {
                    showTransmissionSuccess();
                    logSpectral('Report transmitted to clipboard via fallback method');
                } else {
                    throw new Error('Copy command failed');
                }
            } catch (error) {
                logSpectral(`Fallback clipboard error: ${error.message}`);
                showTransmissionError();
            } finally {
                document.body.removeChild(textArea);
            }
        }
        
        function showTransmissionSuccess() {
            const status = document.getElementById('transmissionStatus');
            const statusText = status.querySelector('div div');
            
            statusText.textContent = 'REPORT TRANSMITTED TO CLIPBOARD';
            statusText.className = 'text-radioactive-green font-mono text-sm neon-glow';
            status.querySelector('div').className = 'bg-black rounded p-2 border border-radioactive-green';
            
            status.classList.remove('hidden');
            
            // Hide after 3 seconds
            setTimeout(() => {
                status.classList.add('hidden');
            }, 3000);
        }
        
        function showTransmissionError() {
            const status = document.getElementById('transmissionStatus');
            const statusText = status.querySelector('div div');
            
            statusText.textContent = 'TRANSMISSION FAILED - CLIPBOARD ACCESS DENIED';
            statusText.className = 'text-red-400 font-mono text-sm';
            status.querySelector('div').className = 'bg-black rounded p-2 border border-red-400';
            
            status.classList.remove('hidden');
            
            // Hide after 5 seconds
            setTimeout(() => {
                status.classList.add('hidden');
            }, 5000);
        }
        
        function startNewAnalysis() {
            // Clear current analysis
            clearEVPInput();
            
            // Hide report section
            document.getElementById('analysisReportSection').classList.add('hidden');
            
            // Scroll back to input
            document.getElementById('evpTranscript').scrollIntoView({ behavior: 'smooth' });
            document.getElementById('evpTranscript').focus();
            
            logSpectral('Started new EVP analysis session');
        }
        
        // Mixtape Sharing System
        function initializeSharingSystem() {
            // Share buttons
            document.getElementById('shareTracklistBtn').addEventListener('click', shareTracklist);
            document.getElementById('shareMixtapeDataBtn').addEventListener('click', shareMixtapeData);
            document.getElementById('generateShareLinkBtn').addEventListener('click', generateShareLink);
            document.getElementById('createSpotifyPlaylistBtn').addEventListener('click', createSpotifyPlaylist);
            document.getElementById('importDataBtn').addEventListener('click', showImportModal);
            
            // Import modal buttons
            document.getElementById('confirmImportBtn').addEventListener('click', confirmImport);
            document.getElementById('cancelImportBtn').addEventListener('click', hideImportModal);
            
            // Close modal on outside click
            document.getElementById('importModal').addEventListener('click', (e) => {
                if (e.target.id === 'importModal') {
                    hideImportModal();
                }
            });
            
            logSpectral('Sharing system initialized');
        }
        
        async function shareTracklist() {
            const tracklist = generateTracklistText();
            
            try {
                await copyToClipboard(tracklist);
                showShareSuccess('TRACKLIST COPIED TO CLIPBOARD');
                logSpectral('Tracklist shared successfully');
            } catch (error) {
                showShareError('Failed to copy tracklist');
                logSpectral(`Tracklist share error: ${error.message}`);
            }
        }
        
        async function shareMixtapeData() {
            const mixtapeData = generateMixtapeDataText();
            
            try {
                await copyToClipboard(mixtapeData);
                showShareSuccess('MIXTAPE DATA EXPORTED TO CLIPBOARD');
                logSpectral('Mixtape data exported successfully');
            } catch (error) {
                showShareError('Failed to export mixtape data');
                logSpectral(`Mixtape export error: ${error.message}`);
            }
        }
        
        async function generateShareLink() {
            const shareableData = generateShareableData();
            const encodedData = btoa(JSON.stringify(shareableData));
            const shareUrl = `${window.location.origin}${window.location.pathname}?mixtape=${encodedData}`;
            
            try {
                await copyToClipboard(shareUrl);
                showShareSuccess('SHARE LINK GENERATED & COPIED');
                logSpectral('Share link generated successfully');
            } catch (error) {
                showShareError('Failed to generate share link');
                logSpectral(`Share link error: ${error.message}`);
            }
        }
        
        function generateTracklistText() {
            const title = appState.mixtape.title || 'Untitled Mixtape';
            const timestamp = new Date().toLocaleDateString();
            
            let tracklist = `üéµ SPEC-TAPE MIXTAPE üéµ
${title.toUpperCase()}
Created: ${timestamp}

`;
            
            // Side A
            if (appState.mixtape.sideA.length > 0) {
                tracklist += `‚óÑ SIDE A ‚ñ∫\n`;
                appState.mixtape.sideA.forEach((track, index) => {
                    tracklist += `${String(index + 1).padStart(2, '0')}. ${track.name} (${track.duration})\n`;
                });
                tracklist += `Total Duration: ${calculateSideDuration('A')}\n\n`;
            }
            
            // Side B
            if (appState.mixtape.sideB.length > 0) {
                tracklist += `‚óÑ SIDE B ‚ñ∫\n`;
                appState.mixtape.sideB.forEach((track, index) => {
                    tracklist += `${String(index + 1).padStart(2, '0')}. ${track.name} (${track.duration})\n`;
                });
                tracklist += `Total Duration: ${calculateSideDuration('B')}\n\n`;
            }
            
            tracklist += `Created with SPEC-TAPE Audio Companion
Kiroween Paranormal Investigation Division`;
            
            return tracklist;
        }
        
        function generateMixtapeDataText() {
            const exportData = {
                title: appState.mixtape.title,
                sideA: appState.mixtape.sideA,
                sideB: appState.mixtape.sideB,
                created: new Date().toISOString(),
                version: '1.0'
            };
            
            return `SPEC-TAPE MIXTAPE DATA EXPORT
================================

${JSON.stringify(exportData, null, 2)}

================================
Import this data into SPEC-TAPE to restore your mixtape.
Created with SPEC-TAPE Audio Companion v1.0`;
        }
        
        function generateShareableData() {
            return {
                title: appState.mixtape.title,
                sideA: appState.mixtape.sideA,
                sideB: appState.mixtape.sideB,
                shared: new Date().toISOString()
            };
        }
        
        async function copyToClipboard(text) {
            if (navigator.clipboard && window.isSecureContext) {
                await navigator.clipboard.writeText(text);
            } else {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                textArea.style.top = '-999999px';
                document.body.appendChild(textArea);
                
                try {
                    textArea.focus();
                    textArea.select();
                    const successful = document.execCommand('copy');
                    if (!successful) {
                        throw new Error('Copy command failed');
                    }
                } finally {
                    document.body.removeChild(textArea);
                }
            }
        }
        
        function showShareSuccess(message) {
            const status = document.getElementById('shareStatus');
            const statusText = status.querySelector('div div');
            
            statusText.textContent = message;
            statusText.className = 'text-radioactive-green font-mono text-xs neon-glow';
            status.querySelector('div').className = 'bg-black rounded p-2 border border-radioactive-green';
            
            status.classList.remove('hidden');
            
            // Hide after 3 seconds
            setTimeout(() => {
                status.classList.add('hidden');
            }, 3000);
        }
        
        function showShareError(message) {
            const status = document.getElementById('shareStatus');
            const statusText = status.querySelector('div div');
            
            statusText.textContent = message;
            statusText.className = 'text-red-400 font-mono text-xs';
            status.querySelector('div').className = 'bg-black rounded p-2 border border-red-400';
            
            status.classList.remove('hidden');
            
            // Hide after 5 seconds
            setTimeout(() => {
                status.classList.add('hidden');
            }, 5000);
        }
        
        // URL Parameter Loading System
        function loadMixtapeFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            const mixtapeParam = urlParams.get('mixtape');
            
            if (mixtapeParam) {
                try {
                    const decodedData = atob(mixtapeParam);
                    const mixtapeData = JSON.parse(decodedData);
                    
                    // Load the shared mixtape
                    appState.mixtape.title = mixtapeData.title || '';
                    appState.mixtape.sideA = mixtapeData.sideA || [];
                    appState.mixtape.sideB = mixtapeData.sideB || [];
                    
                    // Update UI
                    document.getElementById('mixtapeTitle').value = appState.mixtape.title;
                    document.getElementById('titleCharCount').textContent = appState.mixtape.title.length;
                    renderTracks('A');
                    renderTracks('B');
                    updateTrackCounts();
                    updateDisplay();
                    
                    // Save to session
                    saveMixtapeToSession();
                    
                    logSpectral('Mixtape loaded from share link');
                    
                    // Show success message
                    showShareSuccess('SHARED MIXTAPE LOADED SUCCESSFULLY');
                    
                    // Clean up URL
                    window.history.replaceState({}, document.title, window.location.pathname);
                    
                    return true;
                } catch (error) {
                    logSpectral(`Failed to load shared mixtape: ${error.message}`);
                    showShareError('INVALID SHARE LINK');
                }
            }
            
            return false;
        }
        
        // Import Modal Functions
        function showImportModal() {
            document.getElementById('importModal').classList.remove('hidden');
            document.getElementById('importDataInput').focus();
            logSpectral('Import modal opened');
        }
        
        function hideImportModal() {
            document.getElementById('importModal').classList.add('hidden');
            document.getElementById('importDataInput').value = '';
            logSpectral('Import modal closed');
        }
        
        function confirmImport() {
            const importData = document.getElementById('importDataInput').value.trim();
            
            if (!importData) {
                showShareError('NO DATA PROVIDED FOR IMPORT');
                return;
            }
            
            try {
                // Try to parse as JSON first (exported data format)
                let mixtapeData;
                
                if (importData.includes('SPEC-TAPE MIXTAPE DATA EXPORT')) {
                    // Extract JSON from export format
                    const jsonStart = importData.indexOf('{');
                    const jsonEnd = importData.lastIndexOf('}') + 1;
                    const jsonStr = importData.substring(jsonStart, jsonEnd);
                    mixtapeData = JSON.parse(jsonStr);
                } else {
                    // Try direct JSON parse
                    mixtapeData = JSON.parse(importData);
                }
                
                // Validate the data structure
                if (!mixtapeData || typeof mixtapeData !== 'object') {
                    throw new Error('Invalid data format');
                }
                
                // Import the mixtape
                appState.mixtape.title = mixtapeData.title || '';
                appState.mixtape.sideA = Array.isArray(mixtapeData.sideA) ? mixtapeData.sideA : [];
                appState.mixtape.sideB = Array.isArray(mixtapeData.sideB) ? mixtapeData.sideB : [];
                
                // Update UI
                document.getElementById('mixtapeTitle').value = appState.mixtape.title;
                document.getElementById('titleCharCount').textContent = appState.mixtape.title.length;
                renderTracks('A');
                renderTracks('B');
                updateTrackCounts();
                updateDisplay();
                
                // Save to session
                saveMixtapeToSession();
                
                // Close modal and show success
                hideImportModal();
                showShareSuccess('MIXTAPE DATA IMPORTED SUCCESSFULLY');
                
                logSpectral('Mixtape imported successfully');
                
            } catch (error) {
                logSpectral(`Import error: ${error.message}`);
                showShareError('INVALID MIXTAPE DATA FORMAT');
            }
        }
        
        // Spotify Integration Options
        let spotifyAccessToken = null;
        
        // Spotify Playlist Generation System
        async function createSpotifyPlaylist() {
            if (!appState.mixtape.title && appState.mixtape.sideA.length === 0 && appState.mixtape.sideB.length === 0) {
                showShareError('NO MIXTAPE TO CONVERT - CREATE TRACKS FIRST');
                return;
            }
            
            // Check if user wants full Spotify integration or just the guide
            const userChoice = await showSpotifyOptions();
            
            if (userChoice === 'guide') {
                await generateSpotifyGuide();
            } else if (userChoice === 'integrate') {
                await attemptSpotifyIntegration();
            }
        }
        
        async function generateSpotifyCompatiblePlaylist() {
            const allTracks = [...appState.mixtape.sideA, ...appState.mixtape.sideB];
            
            if (allTracks.length === 0) {
                throw new Error('No tracks to convert');
            }
            
            // Create playlist header
            const playlistTitle = appState.mixtape.title || 'Spec-Tape Spectral Mix';
            let spotifyPlaylist = `üéµ SPOTIFY PLAYLIST: ${playlistTitle.toUpperCase()}
Generated from Spec-Tape Paranormal Audio Investigation
Created: ${new Date().toLocaleDateString()}

üéß RECOMMENDED TRACKS BASED ON SPECTRAL ANALYSIS:
================================================================

`;
            
            // Process each track to find Spotify equivalents
            for (let i = 0; i < allTracks.length; i++) {
                const track = allTracks[i];
                const audioType = determineAudioType(track.name, track);
                const spotifyRecommendations = getSpotifyRecommendations(track.name, audioType);
                
                const sideLabel = i < appState.mixtape.sideA.length ? 'A' : 'B';
                const trackNumber = i < appState.mixtape.sideA.length ? i + 1 : i - appState.mixtape.sideA.length + 1;
                
                spotifyPlaylist += `${String(trackNumber).padStart(2, '0')}. ${track.name} (Side ${sideLabel}) - ${track.duration}
    üéµ Audio Type: ${audioType.toUpperCase()}
    üîç Spotify Search: "${spotifyRecommendations.searchQuery}"
    üí´ Recommended Artists: ${spotifyRecommendations.artists.join(', ')}
    üéº Similar Genres: ${spotifyRecommendations.genres.join(', ')}
    
`;
            }
            
            spotifyPlaylist += `
================================================================
üéØ SPOTIFY SEARCH STRATEGY:

1. Search for each "Spotify Search" query in Spotify
2. Look for tracks by the recommended artists
3. Filter by the suggested genres
4. Prioritize tracks with similar mood and energy
5. Create playlist in the same order as your Spec-Tape

üéÆ BONUS: Search for "dark ambient", "horror synth", or "retro wave" 
for additional tracks that match the Spec-Tape aesthetic!

================================================================
Generated by Spec-Tape Audio Companion - Kiroween 2025
Bridging the gap between paranormal investigation and modern music üëªüéµ`;
            
            return spotifyPlaylist;
        }
        
        function getSpotifyRecommendations(trackName, audioType) {
            const recommendations = {
                searchQuery: '',
                artists: [],
                genres: []
            };
            
            // Generate search query based on track name and audio type
            const trackWords = trackName.toLowerCase().split(' ');
            const keyWords = trackWords.filter(word => 
                !['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by'].includes(word)
            );
            
            // Create search query based on audio type and track characteristics
            switch (audioType) {
                case 'ambient':
                    recommendations.searchQuery = `ambient ${keyWords.join(' ')} atmospheric`;
                    recommendations.artists = [
                        'Brian Eno', 'Stars of the Lid', 'Tim Hecker', 'Grouper',
                        'Loscil', 'Biosphere', 'Fennesz', 'Eluvium'
                    ];
                    recommendations.genres = [
                        'ambient', 'drone', 'atmospheric', 'post-rock', 'experimental'
                    ];
                    break;
                    
                case 'spectral':
                    recommendations.searchQuery = `dark electronic ${keyWords.join(' ')} glitch`;
                    recommendations.artists = [
                        'Aphex Twin', 'Autechre', 'Squarepusher', 'Clark',
                        'Burial', 'The Haxan Cloak', 'Ben Frost', 'Actress'
                    ];
                    recommendations.genres = [
                        'idm', 'glitch', 'dark ambient', 'experimental electronic', 'dubstep'
                    ];
                    break;
                    
                case 'rhythmic':
                    recommendations.searchQuery = `dark techno ${keyWords.join(' ')} industrial`;
                    recommendations.artists = [
                        'Gesaffelstein', 'Health', 'Author & Punisher', 'Perturbator',
                        'Carpenter Brut', 'Power Trip', 'Death Grips', 'Clipping'
                    ];
                    recommendations.genres = [
                        'industrial', 'dark techno', 'synthwave', 'hardcore', 'noise'
                    ];
                    break;
                    
                case 'drone':
                    recommendations.searchQuery = `drone music ${keyWords.join(' ')} minimalist`;
                    recommendations.artists = [
                        'Sunn O)))', 'Earth', 'Boris', 'Nadja',
                        'Khanate', 'Bong', 'Sleep', 'Monolithe'
                    ];
                    recommendations.genres = [
                        'drone metal', 'doom', 'minimalism', 'noise', 'sludge'
                    ];
                    break;
                    
                case 'whispers':
                    recommendations.searchQuery = `dark folk ${keyWords.join(' ')} haunting vocals`;
                    recommendations.artists = [
                        'Chelsea Wolfe', 'Emma Ruth Rundle', 'King Woman', 'Lingua Ignota',
                        'Grouper', 'Julianna Barwick', 'Lana Del Rey', 'FKA twigs'
                    ];
                    recommendations.genres = [
                        'dark folk', 'gothic', 'ethereal wave', 'dream pop', 'witch house'
                    ];
                    break;
                    
                default:
                    recommendations.searchQuery = `atmospheric ${keyWords.join(' ')} cinematic`;
                    recommendations.artists = [
                        'Godspeed You! Black Emperor', 'Sigur R√≥s', 'Explosions in the Sky',
                        'Mono', 'A Silver Mt. Zion', 'Swans'
                    ];
                    recommendations.genres = [
                        'post-rock', 'cinematic', 'atmospheric', 'experimental'
                    ];
            }
            
            // Add Halloween/spooky specific recommendations if track name suggests it
            const spookyWords = ['ghost', 'phantom', 'spectral', 'haunted', 'eerie', 'cryptic', 'paranormal'];
            if (spookyWords.some(word => trackName.toLowerCase().includes(word))) {
                recommendations.artists.unshift('John Carpenter', 'Goblin', 'Fabio Frizzi', 'Disasterpeace');
                recommendations.genres.unshift('horror synth', 'dark synthwave');
                recommendations.searchQuery = `horror soundtrack ${recommendations.searchQuery}`;
            }
            
            // Limit to top recommendations
            recommendations.artists = recommendations.artists.slice(0, 4);
            recommendations.genres = recommendations.genres.slice(0, 3);
            
            return recommendations;
        }
        
        // Enhanced Spotify Integration Options
        async function showSpotifyOptions() {
            return new Promise((resolve) => {
                const modal = document.createElement('div');
                modal.className = 'fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50';
                modal.innerHTML = `
                    <div class="bg-gray-800 rounded-lg p-6 border-2 border-gray-600 max-w-md w-full mx-4">
                        <h3 class="text-radioactive-green font-mono text-lg mb-4 text-center neon-glow">
                            SPOTIFY INTEGRATION OPTIONS
                        </h3>
                        
                        <div class="space-y-4 mb-6">
                            <div class="bg-gray-900 rounded p-4 border border-gray-600">
                                <h4 class="text-neon-purple font-mono text-sm mb-2">üìã PLAYLIST GUIDE (RECOMMENDED)</h4>
                                <p class="text-gray-300 text-xs font-mono mb-2">
                                    Generate a detailed guide with search queries and artist recommendations. 
                                    Copy to clipboard and manually create your Spotify playlist.
                                </p>
                                <div class="text-radioactive-green text-xs font-mono">
                                    ‚úÖ Works immediately ‚Ä¢ ‚úÖ No login required ‚Ä¢ ‚úÖ Single-file app
                                </div>
                            </div>
                            
                            <div class="bg-gray-900 rounded p-4 border border-gray-600">
                                <h4 class="text-shock-orange font-mono text-sm mb-2">üéµ FULL INTEGRATION (EXPERIMENTAL)</h4>
                                <p class="text-gray-300 text-xs font-mono mb-2">
                                    Attempt to connect to Spotify Web API and create actual playlists. 
                                    Requires Spotify Premium and authentication.
                                </p>
                                <div class="text-shock-orange text-xs font-mono">
                                    ‚ö†Ô∏è Requires login ‚Ä¢ ‚ö†Ô∏è Premium account ‚Ä¢ ‚ö†Ô∏è External dependencies
                                </div>
                            </div>
                        </div>
                        
                        <div class="flex space-x-3">
                            <button id="chooseGuide" class="btn-3d bg-radioactive-green text-black px-4 py-2 rounded font-mono text-xs font-bold hover:bg-green-400 flex-1">
                                PLAYLIST GUIDE
                            </button>
                            <button id="chooseIntegration" class="btn-3d bg-shock-orange text-black px-4 py-2 rounded font-mono text-xs font-bold hover:bg-orange-400 flex-1">
                                FULL INTEGRATION
                            </button>
                        </div>
                        
                        <div class="text-center mt-3">
                            <button id="cancelSpotify" class="text-gray-400 font-mono text-xs hover:text-white">
                                Cancel
                            </button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                document.getElementById('chooseGuide').addEventListener('click', () => {
                    document.body.removeChild(modal);
                    resolve('guide');
                });
                
                document.getElementById('chooseIntegration').addEventListener('click', () => {
                    document.body.removeChild(modal);
                    resolve('integrate');
                });
                
                document.getElementById('cancelSpotify').addEventListener('click', () => {
                    document.body.removeChild(modal);
                    resolve('cancel');
                });
            });
        }
        
        async function generateSpotifyGuide() {
            try {
                showShareSuccess('ANALYZING SPECTRAL FREQUENCIES...');
                
                // Generate Spotify-compatible playlist guide
                const spotifyPlaylist = await generateSpotifyCompatiblePlaylist();
                
                // Copy to clipboard
                await copyToClipboard(spotifyPlaylist);
                showShareSuccess('SPOTIFY PLAYLIST GUIDE COPIED TO CLIPBOARD');
                
                logSpectral('Spotify playlist guide generated successfully');
                
            } catch (error) {
                logSpectral(`Spotify guide error: ${error.message}`);
                showShareError('FAILED TO GENERATE SPOTIFY GUIDE');
            }
        }
        
        async function attemptSpotifyIntegration() {
            try {
                showShareSuccess('INITIALIZING SPOTIFY WEB API CONNECTION...');
                
                // Check if we're in a secure context (required for Spotify Web API)
                if (!window.isSecureContext) {
                    throw new Error('Spotify Web API requires HTTPS. Please serve this app over HTTPS for full integration.');
                }
                
                // For a single-file app, we'd need to use Spotify's Implicit Grant Flow
                // This requires registering the app with Spotify and getting a client ID
                const clientId = 'YOUR_SPOTIFY_CLIENT_ID'; // Would need to be configured
                
                if (!clientId || clientId === 'YOUR_SPOTIFY_CLIENT_ID') {
                    throw new Error('Spotify integration requires app registration and client ID configuration.');
                }
                
                // Redirect to Spotify authorization (would break single-file architecture)
                const redirectUri = encodeURIComponent(window.location.href);
                const scopes = encodeURIComponent('playlist-modify-public playlist-modify-private');
                const authUrl = `https://accounts.spotify.com/authorize?client_id=${clientId}&response_type=token&redirect_uri=${redirectUri}&scope=${scopes}`;
                
                // Show integration explanation instead of actually redirecting
                showSpotifyIntegrationExplanation();
                
            } catch (error) {
                logSpectral(`Spotify integration error: ${error.message}`);
                showSpotifyIntegrationLimitations(error.message);
            }
        }
        
        function showSpotifyIntegrationExplanation() {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-gray-800 rounded-lg p-6 border-2 border-shock-orange max-w-lg w-full mx-4">
                    <h3 class="text-shock-orange font-mono text-lg mb-4 text-center neon-glow">
                        SPOTIFY WEB API INTEGRATION
                    </h3>
                    
                    <div class="space-y-4 text-sm font-mono text-gray-300">
                        <p>üéµ <strong class="text-radioactive-green">Full Spotify integration is technically possible!</strong></p>
                        
                        <div class="bg-gray-900 rounded p-3 border border-gray-600">
                            <h4 class="text-neon-purple mb-2">What it would enable:</h4>
                            <ul class="text-xs space-y-1">
                                <li>‚úÖ Automatic playlist creation in your Spotify account</li>
                                <li>‚úÖ Real song search and matching</li>
                                <li>‚úÖ Direct playback in the browser (Premium required)</li>
                                <li>‚úÖ Seamless integration with your music library</li>
                            </ul>
                        </div>
                        
                        <div class="bg-gray-900 rounded p-3 border border-gray-600">
                            <h4 class="text-shock-orange mb-2">Why it's not implemented:</h4>
                            <ul class="text-xs space-y-1">
                                <li>üîí Requires Spotify app registration & client ID</li>
                                <li>üåê Needs HTTPS hosting (not local files)</li>
                                <li>üîë OAuth authentication flow</li>
                                <li>üí∞ Spotify Premium account required for playback</li>
                                <li>üì± Would break our single-file architecture</li>
                            </ul>
                        </div>
                        
                        <div class="bg-gray-900 rounded p-3 border border-radioactive-green">
                            <h4 class="text-radioactive-green mb-2">Our solution:</h4>
                            <p class="text-xs">
                                The playlist guide provides intelligent recommendations that you can 
                                easily use to create Spotify playlists manually. It's actually more 
                                flexible since you can customize the selections!
                            </p>
                        </div>
                    </div>
                    
                    <div class="flex justify-center mt-6">
                        <button id="closeExplanation" class="btn-3d bg-radioactive-green text-black px-6 py-2 rounded font-mono text-sm font-bold hover:bg-green-400">
                            UNDERSTOOD - USE PLAYLIST GUIDE
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            document.getElementById('closeExplanation').addEventListener('click', () => {
                document.body.removeChild(modal);
                generateSpotifyGuide(); // Fall back to guide generation
            });
        }
        
        function showSpotifyIntegrationLimitations(errorMessage) {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-gray-800 rounded-lg p-6 border-2 border-red-500 max-w-md w-full mx-4">
                    <h3 class="text-red-400 font-mono text-lg mb-4 text-center">
                        SPOTIFY INTEGRATION LIMITATION
                    </h3>
                    
                    <div class="bg-gray-900 rounded p-4 border border-gray-600 mb-4">
                        <p class="text-gray-300 text-sm font-mono mb-2">
                            <strong class="text-shock-orange">Technical Limitation:</strong>
                        </p>
                        <p class="text-xs font-mono text-gray-400">
                            ${errorMessage}
                        </p>
                    </div>
                    
                    <div class="text-center">
                        <button id="useFallback" class="btn-3d bg-radioactive-green text-black px-4 py-2 rounded font-mono text-xs font-bold hover:bg-green-400">
                            USE PLAYLIST GUIDE INSTEAD
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            document.getElementById('useFallback').addEventListener('click', () => {
                document.body.removeChild(modal);
                generateSpotifyGuide();
            });
        }
        
        // Mixtape Editor Functions
        function initializeMixtapeEditor() {
            // Title input event listener
            const titleInput = document.getElementById('mixtapeTitle');
            titleInput.addEventListener('input', handleTitleInput);
            
            // Add track buttons
            document.getElementById('addTrackA').addEventListener('click', () => addTrack('A'));
            document.getElementById('addTrackB').addEventListener('click', () => addTrack('B'));
            
            // Mixtape action buttons
            document.getElementById('clearMixtape').addEventListener('click', clearMixtape);
            document.getElementById('randomizeTracks').addEventListener('click', randomizeTracks);
            
            // Initialize with empty tracks
            updateTrackCounts();
            
            logSpectral('Mixtape editor initialized');
        }
        
        function handleTitleInput(event) {
            const title = event.target.value;
            const charCount = title.length;
            
            // Update character count
            document.getElementById('titleCharCount').textContent = charCount;
            
            // Validate printable characters only
            const sanitizedTitle = title.replace(/[^\x20-\x7E]/g, '');
            if (sanitizedTitle !== title) {
                event.target.value = sanitizedTitle;
                logSpectral('Invalid characters removed from title');
            }
            
            // Update app state and display
            appState.mixtape.title = sanitizedTitle;
            updateDisplay();
            
            logSpectral(`Title updated: "${sanitizedTitle}"`);
        }
        
        function addTrack(side) {
            const sideData = side === 'A' ? appState.mixtape.sideA : appState.mixtape.sideB;
            
            // Check if we can add more tracks (max 10 per side)
            if (sideData.length >= 10) {
                logSpectral(`Cannot add more tracks to Side ${side} (max 10)`);
                return;
            }
            
            // Add new track to state
            const trackNumber = sideData.length + 1;
            const newTrack = {
                name: `Track ${trackNumber}`,
                duration: generateRandomDuration()
            };
            
            sideData.push(newTrack);
            
            // Update UI
            renderTracks(side);
            updateTrackCounts();
            updateDisplay();
            saveMixtapeToSession();
            
            logSpectral(`Added track to Side ${side}: "${newTrack.name}"`);
        }
        
        function removeTrack(side, index) {
            const sideData = side === 'A' ? appState.mixtape.sideA : appState.mixtape.sideB;
            
            if (index >= 0 && index < sideData.length) {
                const removedTrack = sideData.splice(index, 1)[0];
                
                // Update UI
                renderTracks(side);
                updateTrackCounts();
                updateDisplay();
                saveMixtapeToSession();
                
                logSpectral(`Removed track from Side ${side}: "${removedTrack.name}"`);
            }
        }
        
        function renderTracks(side) {
            const sideData = side === 'A' ? appState.mixtape.sideA : appState.mixtape.sideB;
            const container = document.getElementById(`side${side}Editor`);
            
            // Clear existing tracks
            container.innerHTML = '';
            
            // Render each track
            sideData.forEach((track, index) => {
                const trackElement = createTrackElement(side, index, track);
                container.appendChild(trackElement);
            });
        }
        
        function createTrackElement(side, index, track) {
            const trackDiv = document.createElement('div');
            trackDiv.className = 'track-container rounded p-2';
            
            const sideData = side === 'A' ? appState.mixtape.sideA : appState.mixtape.sideB;
            const canMoveUp = index > 0;
            const canMoveDown = index < sideData.length - 1;
            const canDuplicate = sideData.length < 10;
            
            trackDiv.innerHTML = `
                <div class="flex items-center gap-2">
                    <div class="track-number w-8 h-8 rounded flex items-center justify-center text-xs font-mono flex-shrink-0">
                        ${String(index + 1).padStart(2, '0')}
                    </div>
                    <input 
                        type="text" 
                        class="track-input flex-1 min-w-0 px-2 py-1 rounded text-sm"
                        value="${track.name}"
                        placeholder="Enter track name..."
                        maxlength="40"
                        data-side="${side}"
                        data-index="${index}"
                    >
                    <div class="text-xs font-mono text-gray-400 w-12 text-center flex-shrink-0">
                        ${track.duration}
                    </div>
                    <div class="flex gap-1 flex-shrink-0">
                        <button 
                            class="w-5 h-5 rounded text-xs font-bold bg-gray-600 text-white hover:bg-gray-500 flex items-center justify-center ${!canMoveUp ? 'opacity-30 cursor-not-allowed' : ''}"
                            onclick="moveTrackUp('${side}', ${index})"
                            title="Move up"
                            ${!canMoveUp ? 'disabled' : ''}
                        >
                            ‚Üë
                        </button>
                        <button 
                            class="w-5 h-5 rounded text-xs font-bold bg-gray-600 text-white hover:bg-gray-500 flex items-center justify-center ${!canMoveDown ? 'opacity-30 cursor-not-allowed' : ''}"
                            onclick="moveTrackDown('${side}', ${index})"
                            title="Move down"
                            ${!canMoveDown ? 'disabled' : ''}
                        >
                            ‚Üì
                        </button>
                        <button 
                            class="w-5 h-5 rounded text-xs font-bold bg-blue-600 text-white hover:bg-blue-500 flex items-center justify-center ${!canDuplicate ? 'opacity-30 cursor-not-allowed' : ''}"
                            onclick="duplicateTrack('${side}', ${index})"
                            title="Duplicate track"
                            ${!canDuplicate ? 'disabled' : ''}
                        >
                            ‚ßâ
                        </button>
                        <button 
                            class="remove-track w-5 h-5 rounded text-xs font-bold flex items-center justify-center"
                            onclick="removeTrack('${side}', ${index})"
                            title="Remove track"
                        >
                            √ó
                        </button>
                    </div>
                </div>
            `;
            
            // Add event listener for track name input
            const input = trackDiv.querySelector('.track-input');
            input.addEventListener('input', (e) => handleTrackNameInput(e, side, index));
            
            return trackDiv;
        }
        
        function handleTrackNameInput(event, side, index) {
            const trackName = event.target.value;
            const sideData = side === 'A' ? appState.mixtape.sideA : appState.mixtape.sideB;
            
            // Validate printable characters only
            const sanitizedName = trackName.replace(/[^\x20-\x7E]/g, '');
            if (sanitizedName !== trackName) {
                event.target.value = sanitizedName;
                logSpectral('Invalid characters removed from track name');
            }
            
            // Update track name in state
            if (sideData[index]) {
                sideData[index].name = sanitizedName;
                logSpectral(`Updated track ${index + 1} on Side ${side}: "${sanitizedName}"`);
                
                // Auto-save after a delay
                setTimeout(saveMixtapeToSession, 1000);
            }
        }
        
        function updateTrackCounts() {
            // Update track counts
            document.getElementById('sideACount').textContent = appState.mixtape.sideA.length;
            document.getElementById('sideBCount').textContent = appState.mixtape.sideB.length;
            
            // Update durations
            document.getElementById('sideADuration').textContent = calculateSideDuration('A');
            document.getElementById('sideBDuration').textContent = calculateSideDuration('B');
            
            // Update add button states
            const addButtonA = document.getElementById('addTrackA');
            const addButtonB = document.getElementById('addTrackB');
            
            if (appState.mixtape.sideA.length >= 10) {
                addButtonA.disabled = true;
                addButtonA.textContent = 'SIDE A FULL (10/10)';
                addButtonA.classList.add('opacity-50', 'cursor-not-allowed');
            } else {
                addButtonA.disabled = false;
                addButtonA.textContent = '+ ADD TRACK TO SIDE A';
                addButtonA.classList.remove('opacity-50', 'cursor-not-allowed');
            }
            
            if (appState.mixtape.sideB.length >= 10) {
                addButtonB.disabled = true;
                addButtonB.textContent = 'SIDE B FULL (10/10)';
                addButtonB.classList.add('opacity-50', 'cursor-not-allowed');
            } else {
                addButtonB.disabled = false;
                addButtonB.textContent = '+ ADD TRACK TO SIDE B';
                addButtonB.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        }
        
        function clearMixtape() {
            if (confirm('Are you sure you want to clear all tracks and title?')) {
                // Clear state
                appState.mixtape.title = '';
                appState.mixtape.sideA = [];
                appState.mixtape.sideB = [];
                
                // Clear UI
                document.getElementById('mixtapeTitle').value = '';
                document.getElementById('titleCharCount').textContent = '0';
                renderTracks('A');
                renderTracks('B');
                updateTrackCounts();
                updateDisplay();
                
                logSpectral('Mixtape cleared');
            }
        }
        
        function randomizeTracks() {
            // Expanded track library organized by audio type for unique sounds
            const trackLibrary = {
                ambient: [
                    'Ethereal Echoes', 'Mystic Melodies', 'Celestial Drift', 'Void Whispers',
                    'Astral Wandering', 'Cosmic Lullaby', 'Nebula Dreams', 'Starlight Serenade',
                    'Infinite Expanse', 'Lunar Meditation', 'Solar Winds', 'Deep Space Hymn'
                ],
                spectral: [
                    'Spectral Whispers', 'Digital Phantoms', 'Phantom Frequencies', 'Ghostly Grooves',
                    'Haunted Frequencies', 'Supernatural Synth', 'Eerie Electronics', 'Cryptic Signals',
                    'Poltergeist Pulse', 'Wraith Waves', 'Banshee Broadcast', 'Spirit Static'
                ],
                rhythmic: [
                    'Paranormal Pulse', 'Midnight Manifestation', 'Spectral Beats', 'Phantom Rhythm',
                    'Ghostly Percussion', 'Haunted Heartbeat', 'Supernatural Stomp', 'Eerie Engine',
                    'Cryptic Cadence', 'Otherworldly Drums', 'Spooky Syncopation', 'Mystic Metronome'
                ],
                drone: [
                    'Static Dreams', 'Void Transmission', 'Endless Hum', 'Spectral Sustain',
                    'Phantom Frequency', 'Ethereal Drone', 'Cosmic Background', 'Deep Resonance',
                    'Infinite Tone', 'Astral Buzz', 'Dimensional Hum', 'Quantum Static'
                ],
                whispers: [
                    'Neon Nightmares', 'Cassette Ghosts', 'Retro Revenant', 'Spooky Soundwaves',
                    'Otherworldly Oscillations', 'Haunted Voices', 'Spectral Speech', 'Phantom Phonemes',
                    'Ghostly Gossip', 'Eerie Utterances', 'Cryptic Conversations', 'Mystic Murmurs'
                ]
            };
            
            // Clear existing tracks
            appState.mixtape.sideA = [];
            appState.mixtape.sideB = [];
            
            // Create a pool of all available tracks
            const allTracks = [];
            Object.keys(trackLibrary).forEach(type => {
                trackLibrary[type].forEach(trackName => {
                    allTracks.push({ name: trackName, type: type });
                });
            });
            
            // Shuffle the track pool to ensure randomness
            const shuffledTracks = shuffleArray([...allTracks]);
            
            // Generate tracks for both sides
            const tracksPerSide = Math.floor(Math.random() * 6) + 3; // 3-8 tracks per side
            const totalTracksNeeded = tracksPerSide * 2;
            
            // Ensure we have enough unique tracks
            const selectedTracks = shuffledTracks.slice(0, Math.min(totalTracksNeeded, shuffledTracks.length));
            
            // Distribute tracks between sides
            for (let i = 0; i < tracksPerSide && i < selectedTracks.length; i++) {
                const track = selectedTracks[i];
                appState.mixtape.sideA.push({
                    name: track.name,
                    duration: generateRandomDuration(),
                    audioType: track.type // Store the audio type for consistent sound
                });
            }
            
            for (let i = tracksPerSide; i < totalTracksNeeded && i < selectedTracks.length; i++) {
                const track = selectedTracks[i];
                appState.mixtape.sideB.push({
                    name: track.name,
                    duration: generateRandomDuration(),
                    audioType: track.type // Store the audio type for consistent sound
                });
            }
            
            // Update title if empty
            if (!appState.mixtape.title) {
                const randomTitles = [
                    'Kiroween Spectral Mix', 'Paranormal Playlist Vol. 1',
                    'Haunted Hits Collection', 'Ghostly Grooves Compilation',
                    'Supernatural Soundscape', 'Eerie Audio Archive',
                    'Phantom Frequencies Mix', 'Spectral Sessions Vol. 1',
                    'Otherworldly Oscillations', 'Cryptic Compilation',
                    'Mystic Mixtape Madness', 'Digital S√©ance Sounds'
                ];
                appState.mixtape.title = randomTitles[Math.floor(Math.random() * randomTitles.length)];
                document.getElementById('mixtapeTitle').value = appState.mixtape.title;
                document.getElementById('titleCharCount').textContent = appState.mixtape.title.length;
            }
            
            // Update UI
            renderTracks('A');
            renderTracks('B');
            updateTrackCounts();
            updateDisplay();
            
            logSpectral(`Mixtape randomized with ${selectedTracks.length} unique spectral tracks`);
        }
        
        // Utility function to shuffle an array
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }
        
        // Audio Playback System
        let activeTimeouts = []; // Track all active setTimeout IDs
        
        function playCurrentTrack() {
            if (!audioInitialized) {
                initializeAudio();
                // After initialization, try playing again
                setTimeout(() => {
                    if (audioInitialized) {
                        playCurrentTrack();
                    }
                }, 100);
                return;
            }
            
            const currentSideData = appState.player.currentSide === 'A' ? appState.mixtape.sideA : appState.mixtape.sideB;
            
            if (currentSideData.length === 0) {
                logSpectral('No tracks available to play');
                return;
            }
            
            const currentTrack = currentSideData[appState.player.currentTrack];
            if (!currentTrack) {
                logSpectral('Invalid track index');
                return;
            }
            
            // Stop any currently playing audio
            stopCurrentTrack();
            
            // Determine audio type based on track name and stored data
            const audioType = determineAudioType(currentTrack.name, currentTrack);
            const generator = audioGenerators[audioType];
            
            if (generator) {
                currentAudioTrack = {
                    generator: generator,
                    track: currentTrack,
                    startTime: Tone.now()
                };
                
                // Start progress tracking with actual track duration
                const duration = parseDuration(currentTrack.duration);
                startProgressSimulation(duration);
                
                // Start playing the generated audio
                playGeneratedAudio(generator, currentTrack);
                
                logSpectral(`Playing: "${currentTrack.name}" (${audioType} type)`);
            }
        }
        
        function stopCurrentTrack() {
            // Clear all pending timeouts
            activeTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
            activeTimeouts = [];
            
            // Stop progress tracking
            stopProgressSimulation();
            
            if (currentAudioTrack) {
                const generator = currentAudioTrack.generator;
                
                // Stop all possible audio sources
                if (generator.synth) {
                    try {
                        generator.synth.triggerRelease();
                    } catch (e) {
                        // Synth might not be in a state to release
                    }
                }
                if (generator.noise) {
                    try {
                        generator.noise.stop();
                    } catch (e) {
                        // Noise might already be stopped
                    }
                }
                if (generator.envelope) {
                    try {
                        generator.envelope.triggerRelease();
                    } catch (e) {
                        // Envelope might not be in a state to release
                    }
                }
                
                currentAudioTrack = null;
                logSpectral('Audio stopped');
            }
        }
        
        function determineAudioType(trackName, trackData = null) {
            // If track data has a stored audio type, use that for consistency
            if (trackData && trackData.audioType) {
                return trackData.audioType;
            }
            
            // Otherwise, determine from track name
            const name = trackName.toLowerCase();
            
            if (name.includes('whisper') || name.includes('voice') || name.includes('evp') || 
                name.includes('murmur') || name.includes('utterance') || name.includes('gossip')) {
                return 'whispers';
            } else if (name.includes('spectral') || name.includes('ghost') || name.includes('phantom') || 
                       name.includes('haunted') || name.includes('supernatural') || name.includes('eerie') ||
                       name.includes('poltergeist') || name.includes('wraith') || name.includes('banshee')) {
                return 'spectral';
            } else if (name.includes('pulse') || name.includes('beat') || name.includes('rhythm') || 
                       name.includes('percussion') || name.includes('drum') || name.includes('cadence') ||
                       name.includes('heartbeat') || name.includes('stomp') || name.includes('syncopation')) {
                return 'rhythmic';
            } else if (name.includes('drone') || name.includes('hum') || name.includes('static') || 
                       name.includes('sustain') || name.includes('buzz') || name.includes('transmission') ||
                       name.includes('resonance') || name.includes('tone') || name.includes('frequency')) {
                return 'drone';
            } else if (name.includes('echo') || name.includes('melody') || name.includes('drift') || 
                       name.includes('celestial') || name.includes('astral') || name.includes('cosmic') ||
                       name.includes('nebula') || name.includes('lunar') || name.includes('solar')) {
                return 'ambient';
            } else {
                return 'ambient'; // Default fallback
            }
        }
        
        function playGeneratedAudio(generator, track) {
            const audioType = generator.type;
            const duration = parseDuration(track.duration);
            
            switch (audioType) {
                case 'ambient':
                    playAmbientTrack(generator, duration);
                    break;
                case 'spectral':
                    playSpectralTrack(generator, duration);
                    break;
                case 'rhythmic':
                    playRhythmicTrack(generator, duration);
                    break;
                case 'drone':
                    playDroneTrack(generator, duration);
                    break;
                case 'whispers':
                    playWhispersTrack(generator, duration);
                    break;
            }
        }
        
        function parseDuration(durationStr) {
            const [minutes, seconds] = durationStr.split(':').map(Number);
            return (minutes * 60) + seconds;
        }
        
        function playAmbientTrack(generator, duration) {
            // Spooky minor scale notes with dissonant intervals
            const notes = ['C2', 'Eb2', 'F2', 'Ab2', 'Bb2', 'Db3', 'Eb3'];
            const dissonantNotes = ['C#2', 'F#2', 'A2']; // Tritones and dissonance
            let noteIndex = 0;
            
            const playNote = () => {
                if (currentAudioTrack) {
                    // Occasionally play dissonant notes for eeriness
                    const useDissonance = Math.random() < 0.3;
                    const note = useDissonance 
                        ? dissonantNotes[Math.floor(Math.random() * dissonantNotes.length)]
                        : notes[noteIndex % notes.length];
                    
                    // Vary note duration for unpredictability
                    const noteDuration = Math.random() < 0.2 ? "1n" : "2n";
                    generator.synth.triggerAttackRelease(note, noteDuration);
                    
                    // Add creepy filter sweeps
                    if (generator.filter && Math.random() < 0.4) {
                        generator.filter.frequency.rampTo(Math.random() * 1000 + 200, Math.random() * 2 + 1);
                    }
                    
                    noteIndex++;
                    
                    // Variable timing for unsettling rhythm
                    const delay = Math.random() * 4000 + 1500;
                    const timeoutId = setTimeout(playNote, delay);
                    activeTimeouts.push(timeoutId);
                }
            };
            
            playNote();
            
            // Add occasional "breath" sounds with reverb swells
            const addBreathEffect = () => {
                if (currentAudioTrack && generator.reverb) {
                    generator.reverb.decay = Math.random() * 8 + 4;
                    const timeoutId = setTimeout(addBreathEffect, Math.random() * 8000 + 5000);
                    activeTimeouts.push(timeoutId);
                }
            };
            addBreathEffect();
            
            // Stop after duration
            const durationTimeoutId = setTimeout(() => {
                if (currentAudioTrack && currentAudioTrack.generator === generator) {
                    stopCurrentTrack();
                    advanceToNextTrack();
                }
            }, duration * 1000);
            activeTimeouts.push(durationTimeoutId);
        }
        
        function playSpectralTrack(generator, duration) {
            // High-pitched ghostly frequencies
            const ghostNotes = ['C5', 'D#5', 'F#5', 'A5', 'C6', 'E6'];
            const lowRumbles = ['C2', 'F#2', 'C3']; // Deep ominous tones
            let playing = true;
            
            const playGlitch = () => {
                if (currentAudioTrack && playing) {
                    // Mix high ghostly sounds with occasional deep rumbles
                    const useLowRumble = Math.random() < 0.2;
                    const note = useLowRumble
                        ? lowRumbles[Math.floor(Math.random() * lowRumbles.length)]
                        : ghostNotes[Math.floor(Math.random() * ghostNotes.length)];
                    
                    const glitchDuration = Math.random() * 0.4 + 0.05;
                    generator.synth.triggerAttackRelease(note, glitchDuration);
                    
                    // Add bit crushing for digital ghost effect
                    if (generator.bitCrusher && Math.random() < 0.5) {
                        generator.bitCrusher.bits = Math.floor(Math.random() * 6) + 2;
                    }
                    
                    // Sweep the bandpass filter for "voice-like" quality
                    if (generator.filter) {
                        const targetFreq = Math.random() * 3000 + 800;
                        generator.filter.frequency.rampTo(targetFreq, 0.1);
                    }
                    
                    // Variable delay for unpredictable ghostly presence
                    const delay = Math.random() * 2000 + 200;
                    const timeoutId = setTimeout(playGlitch, delay);
                    activeTimeouts.push(timeoutId);
                }
            };
            
            // Add occasional "EVP burst" - rapid sequence of notes
            const evpBurst = () => {
                if (currentAudioTrack && playing && Math.random() < 0.3) {
                    for (let i = 0; i < 5; i++) {
                        const burstTimeoutId = setTimeout(() => {
                            if (currentAudioTrack) {
                                const note = ghostNotes[Math.floor(Math.random() * ghostNotes.length)];
                                generator.synth.triggerAttackRelease(note, "32n");
                            }
                        }, i * 50);
                        activeTimeouts.push(burstTimeoutId);
                    }
                }
                const timeoutId = setTimeout(evpBurst, Math.random() * 6000 + 3000);
                activeTimeouts.push(timeoutId);
            };
            
            playGlitch();
            evpBurst();
            
            const durationTimeoutId = setTimeout(() => {
                playing = false;
                if (currentAudioTrack && currentAudioTrack.generator === generator) {
                    stopCurrentTrack();
                    advanceToNextTrack();
                }
            }, duration * 1000);
            activeTimeouts.push(durationTimeoutId);
        }
        
        function playRhythmicTrack(generator, duration) {
            // Irregular, unsettling rhythm patterns
            const patterns = [
                [1, 0, 1, 0, 1, 1, 0, 1],      // Basic
                [1, 1, 0, 1, 0, 0, 1, 0],      // Syncopated
                [1, 0, 0, 1, 1, 0, 1, 0, 0, 1], // Irregular
                [1, 1, 1, 0, 1, 0, 0, 0]       // Clustered
            ];
            
            let currentPattern = patterns[0];
            let patternIndex = 0;
            let playing = true;
            let tempo = 250; // Base tempo
            
            const playBeat = () => {
                if (currentAudioTrack && playing) {
                    if (currentPattern[patternIndex % currentPattern.length]) {
                        // Vary pitch slightly for organic feel
                        const pitchVariation = Math.random() < 0.3 ? 'C#1' : 'C1';
                        const velocity = Math.random() * 0.3 + 0.7; // Vary intensity
                        
                        generator.synth.triggerAttackRelease(pitchVariation, '8n', Tone.now(), velocity);
                        
                        // Occasional "double hit" for tension
                        if (Math.random() < 0.15) {
                            const doubleHitId = setTimeout(() => {
                                if (currentAudioTrack) {
                                    generator.synth.triggerAttackRelease('C1', '32n', Tone.now(), 0.5);
                                }
                            }, 50);
                            activeTimeouts.push(doubleHitId);
                        }
                    }
                    patternIndex++;
                    
                    // Occasionally switch patterns for unpredictability
                    if (patternIndex % 16 === 0 && Math.random() < 0.4) {
                        currentPattern = patterns[Math.floor(Math.random() * patterns.length)];
                    }
                    
                    // Vary tempo slightly for unease
                    if (Math.random() < 0.1) {
                        tempo = Math.random() * 100 + 200; // 200-300ms
                    }
                    
                    const timeoutId = setTimeout(playBeat, tempo);
                    activeTimeouts.push(timeoutId);
                }
            };
            
            // Add occasional "heartbeat" effect - two quick beats
            const addHeartbeat = () => {
                if (currentAudioTrack && playing && Math.random() < 0.3) {
                    generator.synth.triggerAttackRelease('C1', '16n', Tone.now(), 0.8);
                    const secondBeatId = setTimeout(() => {
                        if (currentAudioTrack) {
                            generator.synth.triggerAttackRelease('C1', '16n', Tone.now(), 0.6);
                        }
                    }, 150);
                    activeTimeouts.push(secondBeatId);
                }
                
                const timeoutId = setTimeout(addHeartbeat, Math.random() * 8000 + 5000);
                activeTimeouts.push(timeoutId);
            };
            
            playBeat();
            addHeartbeat();
            
            const durationTimeoutId = setTimeout(() => {
                playing = false;
                if (currentAudioTrack && currentAudioTrack.generator === generator) {
                    stopCurrentTrack();
                    advanceToNextTrack();
                }
            }, duration * 1000);
            activeTimeouts.push(durationTimeoutId);
        }
        
        function playDroneTrack(generator, duration) {
            const baseNote = 'C1';
            generator.synth.triggerAttack(baseNote);
            
            // Add ominous frequency modulation with irregular patterns
            let modulation = 0;
            let modulationSpeed = 0.05;
            
            const modulateFreq = () => {
                if (currentAudioTrack) {
                    modulation += modulationSpeed;
                    
                    // Create unsettling wobbles and warbles
                    const wobble = Math.sin(modulation) * 8;
                    const warble = Math.sin(modulation * 3.7) * 3; // Irregular harmonic
                    const freq = Tone.Frequency(baseNote).toFrequency() + wobble + warble;
                    
                    generator.synth.frequency.setValueAtTime(freq, Tone.now());
                    
                    // Occasionally change modulation speed for unpredictability
                    if (Math.random() < 0.02) {
                        modulationSpeed = Math.random() * 0.1 + 0.03;
                    }
                    
                    const timeoutId = setTimeout(modulateFreq, 80);
                    activeTimeouts.push(timeoutId);
                }
            };
            
            // Add creepy filter sweeps
            const filterSweep = () => {
                if (currentAudioTrack && generator.filter) {
                    const targetFreq = Math.random() * 300 + 100;
                    generator.filter.frequency.rampTo(targetFreq, Math.random() * 4 + 2);
                    
                    const timeoutId = setTimeout(filterSweep, Math.random() * 6000 + 3000);
                    activeTimeouts.push(timeoutId);
                }
            };
            
            // Add occasional "presence" - brief volume swells
            const addPresence = () => {
                if (currentAudioTrack && generator.synth) {
                    const currentVolume = generator.synth.volume.value;
                    generator.synth.volume.rampTo(currentVolume + 3, 0.5);
                    
                    const returnTimeoutId = setTimeout(() => {
                        if (generator.synth) {
                            generator.synth.volume.rampTo(currentVolume, 1.5);
                        }
                    }, 800);
                    activeTimeouts.push(returnTimeoutId);
                    
                    const timeoutId = setTimeout(addPresence, Math.random() * 12000 + 8000);
                    activeTimeouts.push(timeoutId);
                }
            };
            
            modulateFreq();
            filterSweep();
            addPresence();
            
            const durationTimeoutId = setTimeout(() => {
                if (currentAudioTrack && currentAudioTrack.generator === generator) {
                    generator.synth.triggerRelease();
                    const fadeTimeoutId = setTimeout(() => {
                        stopCurrentTrack();
                        advanceToNextTrack();
                    }, 2000); // Fade out time
                    activeTimeouts.push(fadeTimeoutId);
                }
            }, duration * 1000);
            activeTimeouts.push(durationTimeoutId);
        }
        
        function playWhispersTrack(generator, duration) {
            generator.noise.start();
            
            let playing = true;
            
            // Create whisper-like patterns with varying intensity
            const triggerWhisper = () => {
                if (currentAudioTrack && playing) {
                    // Vary whisper length for realism
                    const whisperDuration = Math.random() < 0.3 ? "4n" : "2n";
                    generator.envelope.triggerAttackRelease(whisperDuration);
                    
                    // Modulate filter to simulate speech formants
                    if (generator.filter) {
                        const formantFreq = Math.random() * 2000 + 1000;
                        generator.filter.frequency.rampTo(formantFreq, Math.random() * 0.5 + 0.2);
                        generator.filter.Q.value = Math.random() * 8 + 2; // Narrow band for voice-like quality
                    }
                    
                    // Variable timing - sometimes whispers come in clusters
                    const isCluster = Math.random() < 0.3;
                    const delay = isCluster 
                        ? Math.random() * 800 + 200  // Quick succession
                        : Math.random() * 5000 + 2000; // Longer pauses
                    
                    const timeoutId = setTimeout(triggerWhisper, delay);
                    activeTimeouts.push(timeoutId);
                }
            };
            
            // Add "breath" sounds - longer, softer whispers
            const triggerBreath = () => {
                if (currentAudioTrack && playing) {
                    generator.envelope.attack = 1.5;
                    generator.envelope.release = 3;
                    generator.envelope.triggerAttackRelease("1n");
                    
                    // Reset envelope for normal whispers
                    const resetTimeoutId = setTimeout(() => {
                        if (generator.envelope) {
                            generator.envelope.attack = 0.5;
                            generator.envelope.release = 2;
                        }
                    }, 2000);
                    activeTimeouts.push(resetTimeoutId);
                    
                    const timeoutId = setTimeout(triggerBreath, Math.random() * 10000 + 8000);
                    activeTimeouts.push(timeoutId);
                }
            };
            
            // Add occasional "voice-like" sweeps
            const voiceSweep = () => {
                if (currentAudioTrack && playing && generator.filter) {
                    // Simulate vowel formants
                    const vowelFormants = [
                        [800, 1200],  // "ah"
                        [400, 2000],  // "ee"
                        [500, 1000],  // "oo"
                        [600, 1800]   // "eh"
                    ];
                    
                    const formant = vowelFormants[Math.floor(Math.random() * vowelFormants.length)];
                    generator.filter.frequency.rampTo(formant[0], 0.3);
                    
                    const sweepTimeoutId = setTimeout(() => {
                        if (generator.filter) {
                            generator.filter.frequency.rampTo(formant[1], 0.4);
                        }
                    }, 300);
                    activeTimeouts.push(sweepTimeoutId);
                    
                    const timeoutId = setTimeout(voiceSweep, Math.random() * 7000 + 4000);
                    activeTimeouts.push(timeoutId);
                }
            };
            
            triggerWhisper();
            triggerBreath();
            voiceSweep();
            
            const durationTimeoutId = setTimeout(() => {
                playing = false;
                if (currentAudioTrack && currentAudioTrack.generator === generator) {
                    generator.noise.stop();
                    stopCurrentTrack();
                    advanceToNextTrack();
                }
            }, duration * 1000);
            activeTimeouts.push(durationTimeoutId);
        }
        
        function advanceToNextTrack() {
            const currentSideData = appState.player.currentSide === 'A' ? appState.mixtape.sideA : appState.mixtape.sideB;
            
            if (appState.player.isPlaying && currentSideData.length > 0) {
                // Crossfade to next track
                crossfadeToNextTrack();
            }
        }
        
        function crossfadeToNextTrack() {
            const currentSideData = appState.player.currentSide === 'A' ? appState.mixtape.sideA : appState.mixtape.sideB;
            
            // Fade out current track
            if (currentAudioTrack && currentAudioTrack.generator.synth) {
                const currentSynth = currentAudioTrack.generator.synth;
                currentSynth.volume.rampTo(Tone.gainToDb(0.01), 0.5);
            }
            
            // Advance to next track
            appState.player.currentTrack = (appState.player.currentTrack + 1) % currentSideData.length;
            updateDisplay();
            
            // Start next track after crossfade
            const crossfadeTimeoutId = setTimeout(() => {
                if (appState.player.isPlaying) {
                    stopCurrentTrack(); // Clean stop of previous
                    playCurrentTrack(); // Start new track
                    
                    // Fade in new track
                    if (currentAudioTrack && currentAudioTrack.generator.synth) {
                        const newSynth = currentAudioTrack.generator.synth;
                        newSynth.volume.value = Tone.gainToDb(0.01);
                        newSynth.volume.rampTo(Tone.gainToDb(appState.player.volume * 0.8), 0.5);
                    }
                }
            }, 500);
            activeTimeouts.push(crossfadeTimeoutId);
        }
        
        // Audio Visualization System
        let visualizationInterval;
        let audioAnalyzer;
        
        function startAudioVisualization() {
            if (!audioInitialized) return;
            
            // Create analyzer if it doesn't exist
            if (!audioAnalyzer) {
                audioAnalyzer = new Tone.Analyser('waveform', 32);
                Tone.getDestination().connect(audioAnalyzer);
            }
            
            // Start visualization loop
            visualizationInterval = setInterval(updateAudioVisualization, 100);
        }
        
        function stopAudioVisualization() {
            if (visualizationInterval) {
                clearInterval(visualizationInterval);
                visualizationInterval = null;
            }
            
            // Reset visualization
            resetAudioVisualization();
        }
        
        function updateAudioVisualization() {
            if (!audioAnalyzer) return;
            
            try {
                const waveform = audioAnalyzer.getValue();
                const averageLevel = calculateAverageLevel(waveform);
                
                // Update tape spool glow based on audio level
                updateSpoolGlow(averageLevel);
                
                // Update progress bar color intensity
                updateProgressBarIntensity(averageLevel);
                
            } catch (error) {
                // Silently handle analyzer errors
            }
        }
        
        function calculateAverageLevel(waveform) {
            if (!Array.isArray(waveform)) return 0;
            
            const sum = waveform.reduce((acc, val) => acc + Math.abs(val), 0);
            return sum / waveform.length;
        }
        
        function updateSpoolGlow(level) {
            const leftSpool = document.getElementById('leftSpool');
            const rightSpool = document.getElementById('rightSpool');
            
            if (leftSpool && rightSpool) {
                const glowIntensity = Math.min(level * 20, 1); // Scale and clamp
                const glowColor = `rgba(191, 64, 191, ${glowIntensity})`;
                
                leftSpool.style.boxShadow = `0 0 ${10 + glowIntensity * 20}px ${glowColor}`;
                rightSpool.style.boxShadow = `0 0 ${10 + glowIntensity * 20}px ${glowColor}`;
            }
        }
        
        function updateProgressBarIntensity(level) {
            const progressBar = document.querySelector('#tapeProgress > div');
            
            if (progressBar) {
                const intensity = Math.min(level * 10, 1);
                const baseColor = '#40BF40';
                const highlightColor = '#BF40BF';
                
                // Create dynamic gradient based on audio level
                progressBar.style.background = `linear-gradient(90deg, ${baseColor}, ${highlightColor})`;
                progressBar.style.opacity = 0.7 + (intensity * 0.3);
            }
        }
        
        function resetAudioVisualization() {
            const leftSpool = document.getElementById('leftSpool');
            const rightSpool = document.getElementById('rightSpool');
            const progressBar = document.querySelector('#tapeProgress > div');
            
            if (leftSpool) leftSpool.style.boxShadow = '';
            if (rightSpool) rightSpool.style.boxShadow = '';
            if (progressBar) {
                progressBar.style.background = 'linear-gradient(90deg, #40BF40, #BF40BF)';
                progressBar.style.opacity = '1';
            }
        }
        
        function generateRandomDuration() {
            const minutes = Math.floor(Math.random() * 4) + 2; // 2-5 minutes
            const seconds = Math.floor(Math.random() * 60); // 0-59 seconds
            return `${minutes}:${String(seconds).padStart(2, '0')}`;
        }
        
        // Session Persistence Functions
        function saveMixtapeToSession() {
            try {
                const mixtapeData = {
                    title: appState.mixtape.title,
                    sideA: appState.mixtape.sideA,
                    sideB: appState.mixtape.sideB,
                    timestamp: Date.now()
                };
                sessionStorage.setItem('spectape_mixtape', JSON.stringify(mixtapeData));
                logSpectral('Mixtape saved to session');
            } catch (error) {
                logSpectral('Failed to save mixtape to session: ' + error.message);
            }
        }
        
        function loadMixtapeFromSession() {
            try {
                const savedData = sessionStorage.getItem('spectape_mixtape');
                if (savedData) {
                    const mixtapeData = JSON.parse(savedData);
                    
                    // Restore mixtape data
                    appState.mixtape.title = mixtapeData.title || '';
                    appState.mixtape.sideA = mixtapeData.sideA || [];
                    appState.mixtape.sideB = mixtapeData.sideB || [];
                    
                    // Update UI
                    document.getElementById('mixtapeTitle').value = appState.mixtape.title;
                    document.getElementById('titleCharCount').textContent = appState.mixtape.title.length;
                    renderTracks('A');
                    renderTracks('B');
                    updateTrackCounts();
                    updateDisplay();
                    
                    logSpectral('Mixtape loaded from session');
                    return true;
                }
            } catch (error) {
                logSpectral('Failed to load mixtape from session: ' + error.message);
            }
            return false;
        }
        
        // Auto-save functionality
        function setupAutoSave() {
            // Save on title change
            document.getElementById('mixtapeTitle').addEventListener('input', () => {
                setTimeout(saveMixtapeToSession, 500); // Debounce save
            });
            
            // Save periodically
            setInterval(saveMixtapeToSession, 30000); // Save every 30 seconds
            
            // Save on page unload
            window.addEventListener('beforeunload', saveMixtapeToSession);
        }
        
        // Enhanced track management functions
        function moveTrackUp(side, index) {
            const sideData = side === 'A' ? appState.mixtape.sideA : appState.mixtape.sideB;
            
            if (index > 0) {
                // Swap with previous track
                [sideData[index - 1], sideData[index]] = [sideData[index], sideData[index - 1]];
                
                renderTracks(side);
                updateDisplay();
                saveMixtapeToSession();
                
                logSpectral(`Moved track up on Side ${side}`);
            }
        }
        
        function moveTrackDown(side, index) {
            const sideData = side === 'A' ? appState.mixtape.sideA : appState.mixtape.sideB;
            
            if (index < sideData.length - 1) {
                // Swap with next track
                [sideData[index], sideData[index + 1]] = [sideData[index + 1], sideData[index]];
                
                renderTracks(side);
                updateDisplay();
                saveMixtapeToSession();
                
                logSpectral(`Moved track down on Side ${side}`);
            }
        }
        
        function duplicateTrack(side, index) {
            const sideData = side === 'A' ? appState.mixtape.sideA : appState.mixtape.sideB;
            
            if (sideData.length >= 10) {
                logSpectral(`Cannot duplicate track - Side ${side} is full`);
                return;
            }
            
            if (index >= 0 && index < sideData.length) {
                const originalTrack = sideData[index];
                const duplicatedTrack = {
                    name: `${originalTrack.name} (Copy)`,
                    duration: originalTrack.duration
                };
                
                // Insert after the original track
                sideData.splice(index + 1, 0, duplicatedTrack);
                
                renderTracks(side);
                updateTrackCounts();
                updateDisplay();
                saveMixtapeToSession();
                
                logSpectral(`Duplicated track on Side ${side}: "${originalTrack.name}"`);
            }
        }
        
        // Calculate total side duration
        function calculateSideDuration(side) {
            const sideData = side === 'A' ? appState.mixtape.sideA : appState.mixtape.sideB;
            let totalSeconds = 0;
            
            sideData.forEach(track => {
                const [minutes, seconds] = track.duration.split(':').map(Number);
                totalSeconds += (minutes * 60) + seconds;
            });
            
            const totalMinutes = Math.floor(totalSeconds / 60);
            const remainingSeconds = totalSeconds % 60;
            
            return `${totalMinutes}:${String(remainingSeconds).padStart(2, '0')}`;
        }
        
        // Initialize Web Audio API
        function initializeAudio() {
            if (!audioInitialized) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    audioInitialized = true;
                    
                    // Initialize Tone.js
                    Tone.start();
                    
                    // Set initial volume
                    Tone.getDestination().volume.value = Tone.gainToDb(appState.player.volume);
                    
                    // Initialize audio generators
                    initializeAudioGenerators();
                    
                    // Set up audio context monitoring
                    setupAudioContextMonitoring();
                    
                    console.log('Audio Context Initialized');
                    document.getElementById('audioStatus').textContent = 'READY';
                    document.getElementById('audioStatus').className = 'text-radioactive-green neon-glow';
                    
                    logSpectral('Web Audio API initialized successfully');
                } catch (error) {
                    console.warn('Web Audio API not supported:', error);
                    document.getElementById('audioStatus').textContent = 'ERROR';
                    document.getElementById('audioStatus').className = 'text-red-400';
                    logSpectral(`Audio initialization failed: ${error.message}`);
                }
            }
        }
        
        // Audio context monitoring
        function setupAudioContextMonitoring() {
            // Monitor audio context state changes
            if (audioContext) {
                audioContext.addEventListener('statechange', () => {
                    logSpectral(`Audio context state: ${audioContext.state}`);
                    
                    if (audioContext.state === 'suspended') {
                        document.getElementById('audioStatus').textContent = 'SUSPENDED';
                        document.getElementById('audioStatus').className = 'text-shock-orange';
                    } else if (audioContext.state === 'running') {
                        document.getElementById('audioStatus').textContent = 'READY';
                        document.getElementById('audioStatus').className = 'text-radioactive-green neon-glow';
                    }
                });
            }
        }
        
        // Audio generation system
        let currentAudioTrack = null;
        let audioGenerators = {};
        
        function initializeAudioGenerators() {
            // Create different audio generators for various track types
            audioGenerators = {
                ambient: createAmbientGenerator(),
                spectral: createSpectralGenerator(),
                rhythmic: createRhythmicGenerator(),
                drone: createDroneGenerator(),
                whispers: createWhispersGenerator()
            };
            
            logSpectral('Audio generators initialized');
        }
        
        function createAmbientGenerator() {
            const reverb = new Tone.Reverb(8).toDestination();
            const chorus = new Tone.Chorus(4, 2.5, 0.5).connect(reverb);
            const filter = new Tone.Filter(800, "lowpass").connect(chorus);
            const compressor = new Tone.Compressor(-30, 3).connect(filter);
            const synth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "sine" },
                envelope: { attack: 2, decay: 1, sustain: 0.3, release: 4 }
            }).connect(compressor);
            
            return {
                synth: synth,
                filter: filter,
                reverb: reverb,
                chorus: chorus,
                compressor: compressor,
                type: 'ambient'
            };
        }
        
        function createSpectralGenerator() {
            const delay = new Tone.PingPongDelay("8n", 0.4).toDestination();
            const reverb = new Tone.Reverb(8).connect(delay);
            const bitCrusher = new Tone.BitCrusher(3).connect(reverb); // Lower bits for more digital ghost effect
            const distortion = new Tone.Distortion(0.6).connect(bitCrusher); // More distortion for eeriness
            const filter = new Tone.Filter(1500, "bandpass").connect(distortion);
            filter.Q.value = 8; // Narrow band for voice-like quality
            
            const synth = new Tone.MonoSynth({
                oscillator: { type: "sawtooth" },
                envelope: { attack: 0.05, decay: 0.2, sustain: 0.3, release: 0.8 }
            }).connect(filter);
            
            return {
                synth: synth,
                distortion: distortion,
                delay: delay,
                bitCrusher: bitCrusher,
                filter: filter,
                reverb: reverb,
                type: 'spectral'
            };
        }
        
        function createRhythmicGenerator() {
            const compressor = new Tone.Compressor(-30, 3).toDestination();
            const filter = new Tone.Filter(400, "highpass").connect(compressor);
            const synth = new Tone.MembraneSynth({
                pitchDecay: 0.05,
                octaves: 2,
                oscillator: { type: "sine" },
                envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 1.4 }
            }).connect(filter);
            
            return {
                synth: synth,
                filter: filter,
                compressor: compressor,
                type: 'rhythmic'
            };
        }
        
        function createDroneGenerator() {
            const reverb = new Tone.Reverb(15).toDestination(); // Very long reverb for ominous atmosphere
            reverb.wet.value = 0.8;
            
            const filter = new Tone.Filter(150, "lowpass").connect(reverb);
            filter.rolloff = -24; // Steeper rolloff for darker tone
            
            // Use two oscillators for richer, more unsettling sound
            const synth = new Tone.Synth({
                oscillator: { 
                    type: "triangle",
                    partials: [1, 0.5, 0.3, 0.2] // Add harmonics for complexity
                },
                envelope: { attack: 5, decay: 0, sustain: 1, release: 10 }
            }).connect(filter);
            
            return {
                synth: synth,
                filter: filter,
                reverb: reverb,
                type: 'drone'
            };
        }
        
        function createWhispersGenerator() {
            const reverb = new Tone.Reverb(10).toDestination(); // Longer reverb for ghostly presence
            reverb.wet.value = 0.7; // More wet signal for ethereal quality
            
            const filter = new Tone.Filter(1500, "bandpass").connect(reverb);
            filter.Q.value = 6; // Resonant filter for voice-like formants
            
            const noise = new Tone.Noise("pink").connect(filter);
            noise.volume.value = -10; // Quieter for subtlety
            
            const envelope = new Tone.AmplitudeEnvelope({
                attack: 0.8,
                decay: 1.5,
                sustain: 0.2,
                release: 3
            }).connect(filter);
            noise.connect(envelope);
            
            return {
                noise: noise,
                envelope: envelope,
                filter: filter,
                reverb: reverb,
                type: 'whispers'
            };
        }
        
        // Utility function for logging with 90s aesthetic
        function logSpectral(message) {
            console.log(`[SPEC-TAPE] ${message}`);
        }
        
        // Browser compatibility checks
        checkBrowserCompatibility();
        applyBrowserFixes();
        
        // Run diagnostic tests
        runDiagnosticTests();
        
        // Enable Konami code debugging
        debugKonamiCode();
        
        // Final system validation
        validateSystemIntegration();
        
        logSpectral('Core systems loaded. Ready for spectral analysis.');
    </script>
</body>
</html>